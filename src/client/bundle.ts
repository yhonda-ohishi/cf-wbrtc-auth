export const CLIENT_JS = "\"use strict\";\nvar ClientUI = (() => {\n  var __defProp = Object.defineProperty;\n  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;\n  var __getOwnPropNames = Object.getOwnPropertyNames;\n  var __hasOwnProp = Object.prototype.hasOwnProperty;\n  var __export = (target, all) => {\n    for (var name in all)\n      __defProp(target, name, { get: all[name], enumerable: true });\n  };\n  var __copyProps = (to, from, except, desc) => {\n    if (from && typeof from === \"object\" || typeof from === \"function\") {\n      for (let key of __getOwnPropNames(from))\n        if (!__hasOwnProp.call(to, key) && key !== except)\n          __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });\n    }\n    return to;\n  };\n  var __toCommonJS = (mod) => __copyProps(__defProp({}, \"__esModule\", { value: true }), mod);\n\n  // src/client/ui.ts\n  var ui_exports = {};\n  __export(ui_exports, {\n    initializeUI: () => initializeUI\n  });\n\n  // src/client/ws-client.ts\n  var SignalingClient = class {\n    ws = null;\n    wsUrl;\n    token;\n    reconnectAttempts = 0;\n    maxReconnectAttempts = 10;\n    reconnectTimeout = null;\n    isManualDisconnect = false;\n    isAuthenticated = false;\n    // Event callbacks\n    onAuthenticated = null;\n    onAuthError = null;\n    onAppStatus = null;\n    onAppsListReceived = null;\n    onOffer = null;\n    onAnswer = null;\n    onIce = null;\n    onConnected = null;\n    onDisconnected = null;\n    onError = null;\n    constructor(wsUrl, token = null) {\n      this.wsUrl = wsUrl;\n      this.token = token;\n    }\n    /**\n     * Connect to the WebSocket signaling server\n     */\n    async connect() {\n      if (this.ws?.readyState === WebSocket.OPEN || this.ws?.readyState === WebSocket.CONNECTING) {\n        return;\n      }\n      this.isManualDisconnect = false;\n      return new Promise((resolve, reject) => {\n        try {\n          const url = new URL(this.wsUrl);\n          if (this.token) {\n            url.searchParams.set(\"token\", this.token);\n          }\n          this.ws = new WebSocket(url.toString());\n          this.ws.onopen = () => {\n            this.reconnectAttempts = 0;\n            this.onConnected?.();\n            this.sendAuth();\n            resolve();\n          };\n          this.ws.onmessage = (event) => {\n            this.handleMessage(event.data);\n          };\n          this.ws.onerror = (event) => {\n            console.error(\"WebSocket error:\", event);\n            this.onError?.({ message: \"WebSocket error occurred\" });\n            reject(new Error(\"WebSocket connection error\"));\n          };\n          this.ws.onclose = (event) => {\n            this.isAuthenticated = false;\n            this.onDisconnected?.();\n            if (!this.isManualDisconnect) {\n              this.scheduleReconnect();\n            }\n          };\n        } catch (error) {\n          reject(error);\n        }\n      });\n    }\n    /**\n     * Disconnect from the WebSocket server\n     */\n    disconnect() {\n      this.isManualDisconnect = true;\n      this.isAuthenticated = false;\n      if (this.reconnectTimeout !== null) {\n        clearTimeout(this.reconnectTimeout);\n        this.reconnectTimeout = null;\n      }\n      if (this.ws) {\n        this.ws.close();\n        this.ws = null;\n      }\n    }\n    /**\n     * Check if the client is connected and authenticated\n     */\n    isConnected() {\n      return this.ws?.readyState === WebSocket.OPEN && this.isAuthenticated;\n    }\n    /**\n     * Send authentication message\n     */\n    sendAuth() {\n      this.send({\n        type: \"auth\",\n        payload: { token: this.token }\n      });\n    }\n    /**\n     * Send WebRTC offer to a specific app\n     */\n    sendOffer(targetAppId, sdp) {\n      this.send({\n        type: \"offer\",\n        payload: { targetAppId, sdp }\n      });\n    }\n    /**\n     * Send WebRTC answer\n     */\n    sendAnswer(sdp) {\n      this.send({\n        type: \"answer\",\n        payload: { sdp }\n      });\n    }\n    /**\n     * Send ICE candidate\n     */\n    sendIce(candidate, targetAppId) {\n      this.send({\n        type: \"ice\",\n        payload: { candidate, targetAppId }\n      });\n    }\n    /**\n     * Request list of online apps\n     */\n    getApps() {\n      this.send({\n        type: \"get_apps\",\n        payload: {}\n      });\n    }\n    /**\n     * Send a message to the server\n     */\n    send(message) {\n      if (this.ws?.readyState !== WebSocket.OPEN) {\n        console.error(\"WebSocket is not open. Cannot send message:\", message);\n        return;\n      }\n      try {\n        this.ws.send(JSON.stringify(message));\n      } catch (error) {\n        console.error(\"Failed to send message:\", error);\n        this.onError?.({ message: \"Failed to send message\" });\n      }\n    }\n    /**\n     * Handle incoming WebSocket messages\n     */\n    handleMessage(data) {\n      try {\n        const message = JSON.parse(data);\n        switch (message.type) {\n          case \"auth_ok\":\n            this.isAuthenticated = true;\n            this.onAuthenticated?.(message.payload);\n            break;\n          case \"auth_error\":\n            this.isAuthenticated = false;\n            this.onAuthError?.(message.payload);\n            break;\n          case \"apps_list\":\n            this.onAppsListReceived?.(message.payload);\n            break;\n          case \"app_status\":\n            this.onAppStatus?.(message.payload);\n            break;\n          case \"offer\":\n            this.onOffer?.(message.payload);\n            break;\n          case \"answer\":\n            this.onAnswer?.(message.payload);\n            break;\n          case \"ice\":\n            this.onIce?.(message.payload);\n            break;\n          case \"error\":\n            this.onError?.(message.payload);\n            break;\n          default:\n            console.warn(\"Unknown message type:\", message.type);\n        }\n      } catch (error) {\n        console.error(\"Failed to parse message:\", error);\n        this.onError?.({ message: \"Failed to parse server message\" });\n      }\n    }\n    /**\n     * Schedule reconnection with exponential backoff\n     */\n    scheduleReconnect() {\n      if (this.reconnectAttempts >= this.maxReconnectAttempts) {\n        console.error(\"Max reconnection attempts reached\");\n        this.onError?.({ message: \"Failed to reconnect after multiple attempts\" });\n        return;\n      }\n      const delay = Math.min(1e3 * Math.pow(2, this.reconnectAttempts), 3e4);\n      this.reconnectAttempts++;\n      console.log(`Reconnecting in ${delay}ms (attempt ${this.reconnectAttempts}/${this.maxReconnectAttempts})`);\n      this.reconnectTimeout = window.setTimeout(() => {\n        this.connect().catch((error) => {\n          console.error(\"Reconnection failed:\", error);\n        });\n      }, delay);\n    }\n    /**\n     * Update the JWT token (useful for token refresh)\n     */\n    updateToken(token) {\n      this.token = token;\n      if (this.ws?.readyState === WebSocket.OPEN) {\n        this.disconnect();\n        this.connect().catch((error) => {\n          console.error(\"Failed to reconnect with new token:\", error);\n        });\n      }\n    }\n  };\n\n  // src/client/webrtc-client.ts\n  var DEFAULT_ICE_SERVERS = [\n    { urls: \"stun:stun.l.google.com:19302\" },\n    { urls: \"stun:stun1.l.google.com:19302\" }\n  ];\n  var WebRTCClient = class {\n    signalingClient;\n    peerConnections = /* @__PURE__ */ new Map();\n    iceServers;\n    // Event callbacks\n    onDataChannelOpen = null;\n    onDataChannelClose = null;\n    onDataChannelMessage = null;\n    onConnectionStateChange = null;\n    onError = null;\n    constructor(signalingClient, iceServers = DEFAULT_ICE_SERVERS) {\n      this.signalingClient = signalingClient;\n      this.iceServers = iceServers;\n      this.setupSignalingHandlers();\n    }\n    /**\n     * Set up handlers for signaling messages\n     */\n    setupSignalingHandlers() {\n      this.signalingClient.onAnswer = (payload) => {\n        const { sdp, appId } = payload;\n        this.handleAnswer(appId, sdp);\n      };\n      this.signalingClient.onIce = (payload) => {\n        const { candidate, appId } = payload;\n        if (appId) {\n          this.handleIceCandidate(appId, candidate);\n        }\n      };\n      this.signalingClient.onAppStatus = (payload) => {\n        if (payload.status === \"offline\") {\n          this.disconnect(payload.appId);\n        }\n      };\n    }\n    /**\n     * Connect to a specific app by creating an offer\n     */\n    async connectToApp(appId) {\n      if (this.peerConnections.has(appId)) {\n        const existing = this.peerConnections.get(appId);\n        if (existing.dataChannel?.readyState === \"open\") {\n          return existing.dataChannel;\n        }\n        this.disconnect(appId);\n      }\n      const pc = new RTCPeerConnection({\n        iceServers: this.iceServers\n      });\n      const dataChannel = pc.createDataChannel(\"data\", {\n        ordered: true\n      });\n      const peerConnection = {\n        pc,\n        dataChannel,\n        appId\n      };\n      this.peerConnections.set(appId, peerConnection);\n      this.setupPeerConnectionHandlers(appId, pc);\n      this.setupDataChannelHandlers(appId, dataChannel);\n      try {\n        const offer = await pc.createOffer();\n        await pc.setLocalDescription(offer);\n        this.signalingClient.sendOffer(appId, offer.sdp);\n        return new Promise((resolve, reject) => {\n          const timeout = setTimeout(() => {\n            reject(new Error(\"Data channel connection timeout\"));\n            this.disconnect(appId);\n          }, 3e4);\n          dataChannel.onopen = () => {\n            clearTimeout(timeout);\n            this.onDataChannelOpen?.({ appId });\n            resolve(dataChannel);\n          };\n          dataChannel.onerror = (error) => {\n            clearTimeout(timeout);\n            this.onError?.({\n              appId,\n              message: `Data channel error: ${error}`\n            });\n            reject(error);\n          };\n        });\n      } catch (error) {\n        this.disconnect(appId);\n        this.onError?.({\n          appId,\n          message: `Failed to create offer: ${error}`\n        });\n        throw error;\n      }\n    }\n    /**\n     * Disconnect from a specific app or all apps\n     */\n    disconnect(appId) {\n      if (appId) {\n        const peerConnection = this.peerConnections.get(appId);\n        if (peerConnection) {\n          this.closePeerConnection(peerConnection);\n          this.peerConnections.delete(appId);\n        }\n      } else {\n        for (const [id, pc] of this.peerConnections.entries()) {\n          this.closePeerConnection(pc);\n        }\n        this.peerConnections.clear();\n      }\n    }\n    /**\n     * Send a message to a specific app\n     */\n    sendMessage(appId, data) {\n      const peerConnection = this.peerConnections.get(appId);\n      if (!peerConnection?.dataChannel) {\n        this.onError?.({\n          appId,\n          message: \"No data channel available for this app\"\n        });\n        return;\n      }\n      if (peerConnection.dataChannel.readyState !== \"open\") {\n        this.onError?.({\n          appId,\n          message: `Data channel is not open (state: ${peerConnection.dataChannel.readyState})`\n        });\n        return;\n      }\n      try {\n        peerConnection.dataChannel.send(data);\n      } catch (error) {\n        this.onError?.({\n          appId,\n          message: `Failed to send message: ${error}`\n        });\n      }\n    }\n    /**\n     * Get connection state for a specific app\n     */\n    getConnectionState(appId) {\n      const peerConnection = this.peerConnections.get(appId);\n      return peerConnection?.pc.connectionState || null;\n    }\n    /**\n     * Get data channel state for a specific app\n     */\n    getDataChannelState(appId) {\n      const peerConnection = this.peerConnections.get(appId);\n      return peerConnection?.dataChannel?.readyState || null;\n    }\n    /**\n     * Get list of connected app IDs\n     */\n    getConnectedApps() {\n      return Array.from(this.peerConnections.keys()).filter((appId) => {\n        const pc = this.peerConnections.get(appId);\n        return pc?.dataChannel?.readyState === \"open\";\n      });\n    }\n    /**\n     * Handle incoming answer from app\n     */\n    async handleAnswer(appId, sdp) {\n      const peerConnection = this.peerConnections.get(appId);\n      if (!peerConnection) {\n        console.warn(`Received answer for unknown app: ${appId}`);\n        return;\n      }\n      try {\n        const answer = new RTCSessionDescription({\n          type: \"answer\",\n          sdp\n        });\n        await peerConnection.pc.setRemoteDescription(answer);\n      } catch (error) {\n        this.onError?.({\n          appId,\n          message: `Failed to set remote description: ${error}`\n        });\n      }\n    }\n    /**\n     * Handle incoming ICE candidate from app\n     */\n    async handleIceCandidate(appId, candidate) {\n      const peerConnection = this.peerConnections.get(appId);\n      if (!peerConnection) {\n        console.warn(`Received ICE candidate for unknown app: ${appId}`);\n        return;\n      }\n      try {\n        await peerConnection.pc.addIceCandidate(candidate);\n      } catch (error) {\n        this.onError?.({\n          appId,\n          message: `Failed to add ICE candidate: ${error}`\n        });\n      }\n    }\n    /**\n     * Set up event handlers for a peer connection\n     */\n    setupPeerConnectionHandlers(appId, pc) {\n      pc.onicecandidate = (event) => {\n        if (event.candidate) {\n          this.signalingClient.sendIce(event.candidate, appId);\n        }\n      };\n      pc.onconnectionstatechange = () => {\n        const state = pc.connectionState;\n        this.onConnectionStateChange?.({ appId, state });\n        if (state === \"failed\" || state === \"closed\") {\n          this.disconnect(appId);\n        }\n      };\n      pc.oniceconnectionstatechange = () => {\n        const state = pc.iceConnectionState;\n        if (state === \"failed\" || state === \"closed\") {\n          this.onError?.({\n            appId,\n            message: `ICE connection ${state}`\n          });\n        }\n      };\n      pc.ondatachannel = (event) => {\n        console.warn(\"Unexpected data channel from remote peer:\", event.channel.label);\n      };\n    }\n    /**\n     * Set up event handlers for a data channel\n     */\n    setupDataChannelHandlers(appId, dataChannel) {\n      dataChannel.onopen = () => {\n        this.onDataChannelOpen?.({ appId });\n      };\n      dataChannel.onclose = () => {\n        this.onDataChannelClose?.({ appId });\n      };\n      dataChannel.onmessage = (event) => {\n        this.onDataChannelMessage?.({\n          appId,\n          data: event.data\n        });\n      };\n      dataChannel.onerror = (error) => {\n        this.onError?.({\n          appId,\n          message: `Data channel error: ${error}`\n        });\n      };\n    }\n    /**\n     * Close a peer connection and clean up resources\n     */\n    closePeerConnection(peerConnection) {\n      const { pc, dataChannel, appId } = peerConnection;\n      if (dataChannel) {\n        try {\n          dataChannel.close();\n        } catch (error) {\n          console.error(\"Error closing data channel:\", error);\n        }\n      }\n      try {\n        pc.close();\n      } catch (error) {\n        console.error(\"Error closing peer connection:\", error);\n      }\n      this.onDataChannelClose?.({ appId });\n    }\n  };\n\n  // src/client/ui.ts\n  var UIManager = class {\n    signalingClient = null;\n    webrtcClient = null;\n    apps = /* @__PURE__ */ new Map();\n    userInfo = null;\n    messageLog = [];\n    // DOM Elements\n    loginSection;\n    userSection;\n    appListSection;\n    connectionSection;\n    messageSection;\n    userEmailSpan;\n    appListDiv;\n    messageLogDiv;\n    wsStatusSpan;\n    logoutBtn;\n    constructor() {\n      this.initializeDOM();\n      this.checkAuthStatus();\n    }\n    initializeDOM() {\n      this.loginSection = document.getElementById(\"login-section\");\n      this.userSection = document.getElementById(\"user-section\");\n      this.appListSection = document.getElementById(\"app-list-section\");\n      this.connectionSection = document.getElementById(\"connection-section\");\n      this.messageSection = document.getElementById(\"message-section\");\n      this.userEmailSpan = document.getElementById(\"user-email\");\n      this.appListDiv = document.getElementById(\"app-list\");\n      this.messageLogDiv = document.getElementById(\"message-log\");\n      this.wsStatusSpan = document.getElementById(\"ws-status\");\n      this.logoutBtn = document.getElementById(\"logout-btn\");\n      this.logoutBtn.addEventListener(\"click\", () => this.handleLogout());\n      document.getElementById(\"login-btn\")?.addEventListener(\"click\", () => this.handleLogin());\n      document.getElementById(\"refresh-apps-btn\")?.addEventListener(\"click\", () => this.refreshApps());\n      document.getElementById(\"send-message-btn\")?.addEventListener(\"click\", () => this.handleSendMessage());\n      document.getElementById(\"clear-log-btn\")?.addEventListener(\"click\", () => this.clearMessageLog());\n    }\n    async checkAuthStatus() {\n      try {\n        const response = await fetch(\"/api/me\");\n        if (response.ok) {\n          this.userInfo = await response.json();\n          this.showUserInterface();\n          this.initializeWebSocket();\n        } else {\n          this.showLogin();\n        }\n      } catch (error) {\n        console.error(\"Auth check failed:\", error);\n        this.showLogin();\n      }\n    }\n    getToken() {\n      const cookies = document.cookie.split(\";\");\n      for (const cookie of cookies) {\n        const [name, value] = cookie.trim().split(\"=\");\n        if (name === \"token\") {\n          return value;\n        }\n      }\n      return localStorage.getItem(\"token\");\n    }\n    clearToken() {\n      document.cookie = \"token=; expires=Thu, 01 Jan 1970 00:00:00 UTC; path=/;\";\n      localStorage.removeItem(\"token\");\n    }\n    showLogin() {\n      this.loginSection.style.display = \"block\";\n      this.userSection.style.display = \"none\";\n      this.appListSection.style.display = \"none\";\n      this.connectionSection.style.display = \"none\";\n      this.messageSection.style.display = \"none\";\n    }\n    showUserInterface() {\n      this.loginSection.style.display = \"none\";\n      this.userSection.style.display = \"block\";\n      this.appListSection.style.display = \"block\";\n      this.connectionSection.style.display = \"block\";\n      this.messageSection.style.display = \"block\";\n      if (this.userInfo) {\n        this.userEmailSpan.textContent = this.userInfo.email;\n      }\n    }\n    handleLogin() {\n      window.location.href = \"/auth/login\";\n    }\n    handleLogout() {\n      this.clearToken();\n      if (this.signalingClient) {\n        this.signalingClient.disconnect();\n      }\n      if (this.webrtcClient) {\n        this.webrtcClient.disconnect();\n      }\n      this.showLogin();\n    }\n    async initializeWebSocket() {\n      const protocol = window.location.protocol === \"https:\" ? \"wss:\" : \"ws:\";\n      const wsUrl = `${protocol}//${window.location.host}/ws`;\n      this.signalingClient = new SignalingClient(wsUrl);\n      this.signalingClient.onConnected = () => {\n        this.updateWSStatus(\"connected\");\n      };\n      this.signalingClient.onDisconnected = () => {\n        this.updateWSStatus(\"disconnected\");\n      };\n      this.signalingClient.onAuthenticated = (payload) => {\n        console.log(\"Authenticated:\", payload);\n        this.updateWSStatus(\"authenticated\");\n        this.signalingClient?.getApps();\n      };\n      this.signalingClient.onAuthError = (payload) => {\n        console.error(\"Auth error:\", payload);\n        this.updateWSStatus(\"error\");\n        alert(\"Authentication failed: \" + payload.error);\n        this.handleLogout();\n      };\n      this.signalingClient.onAppsListReceived = (payload) => {\n        console.log(\"Apps list received:\", payload);\n        payload.apps.forEach((app) => {\n          this.apps.set(app.appId, {\n            id: app.appId,\n            name: app.name,\n            capabilities: app.capabilities,\n            status: app.status\n          });\n        });\n        this.renderAppList();\n      };\n      this.signalingClient.onAppStatus = (payload) => {\n        console.log(\"App status update:\", payload);\n        const app = this.apps.get(payload.appId);\n        if (app) {\n          app.status = payload.status;\n          if (payload.name) app.name = payload.name;\n          if (payload.capabilities) app.capabilities = payload.capabilities;\n        } else {\n          this.apps.set(payload.appId, {\n            id: payload.appId,\n            name: payload.name || payload.appId,\n            capabilities: payload.capabilities,\n            status: payload.status\n          });\n        }\n        this.renderAppList();\n      };\n      this.signalingClient.onError = (payload) => {\n        console.error(\"WebSocket error:\", payload);\n        this.addLog(\"System\", \"Error: \" + payload.message, \"received\");\n      };\n      this.webrtcClient = new WebRTCClient(this.signalingClient);\n      this.webrtcClient.onDataChannelOpen = ({ appId }) => {\n        console.log(\"Data channel opened:\", appId);\n        this.addLog(appId, \"Connection established\", \"received\");\n        this.renderAppList();\n      };\n      this.webrtcClient.onDataChannelClose = ({ appId }) => {\n        console.log(\"Data channel closed:\", appId);\n        this.addLog(appId, \"Connection closed\", \"received\");\n        this.renderAppList();\n      };\n      this.webrtcClient.onDataChannelMessage = ({ appId, data }) => {\n        console.log(\"Message from app:\", appId, data);\n        const message = typeof data === \"string\" ? data : `[Binary data: ${data.byteLength} bytes]`;\n        this.addLog(appId, message, \"received\");\n      };\n      this.webrtcClient.onConnectionStateChange = ({ appId, state }) => {\n        console.log(\"Connection state change:\", appId, state);\n        this.renderAppList();\n      };\n      this.webrtcClient.onError = ({ appId, message }) => {\n        console.error(\"WebRTC error:\", appId, message);\n        this.addLog(appId || \"System\", \"Error: \" + message, \"received\");\n      };\n      try {\n        await this.signalingClient.connect();\n      } catch (error) {\n        console.error(\"Failed to connect to WebSocket:\", error);\n        this.updateWSStatus(\"error\");\n      }\n    }\n    updateWSStatus(status) {\n      this.wsStatusSpan.textContent = status;\n      this.wsStatusSpan.className = `status-${status}`;\n    }\n    async refreshApps() {\n      if (this.signalingClient?.isConnected()) {\n        this.signalingClient.getApps();\n      } else {\n        try {\n          const token = this.getToken();\n          const response = await fetch(\"/api/apps\", {\n            headers: {\n              \"Authorization\": `Bearer ${token}`\n            }\n          });\n          if (response.ok) {\n            const data = await response.json();\n            this.apps.clear();\n            data.apps.forEach((app) => {\n              this.apps.set(app.id, {\n                id: app.id,\n                name: app.name,\n                capabilities: app.capabilities,\n                status: \"offline\"\n              });\n            });\n            this.renderAppList();\n          }\n        } catch (error) {\n          console.error(\"Failed to fetch apps:\", error);\n        }\n      }\n    }\n    renderAppList() {\n      const appArray = Array.from(this.apps.values());\n      if (appArray.length === 0) {\n        this.appListDiv.innerHTML = '<p class=\"no-apps\">No apps registered. Register an app to get started.</p>';\n        return;\n      }\n      this.appListDiv.innerHTML = appArray.map((app) => {\n        const isOnline = app.status === \"online\";\n        const connectionState = this.webrtcClient?.getConnectionState(app.id);\n        const dataChannelState = this.webrtcClient?.getDataChannelState(app.id);\n        const isConnected = dataChannelState === \"open\";\n        return `\n        <div class=\"app-card ${isOnline ? \"online\" : \"offline\"}\">\n          <div class=\"app-header\">\n            <span class=\"app-name\">${this.escapeHtml(app.name)}</span>\n            <span class=\"app-status ${isOnline ? \"status-online\" : \"status-offline\"}\">\n              ${isOnline ? \"\\u25CF Online\" : \"\\u25CB Offline\"}\n            </span>\n          </div>\n          <div class=\"app-details\">\n            <div class=\"app-id\">ID: ${this.escapeHtml(app.id)}</div>\n            ${app.capabilities && app.capabilities.length > 0 ? `<div class=\"app-capabilities\">Capabilities: ${app.capabilities.join(\", \")}</div>` : \"\"}\n            ${connectionState ? `<div class=\"app-connection-state\">WebRTC: ${connectionState}</div>` : \"\"}\n            ${dataChannelState ? `<div class=\"app-datachannel-state\">DataChannel: ${dataChannelState}</div>` : \"\"}\n          </div>\n          <div class=\"app-actions\">\n            ${isOnline && !isConnected ? `<button class=\"btn btn-primary\" onclick=\"window.uiManager.connectToApp('${app.id}')\">Connect</button>` : \"\"}\n            ${isConnected ? `<button class=\"btn btn-danger\" onclick=\"window.uiManager.disconnectFromApp('${app.id}')\">Disconnect</button>` : \"\"}\n          </div>\n        </div>\n      `;\n      }).join(\"\");\n    }\n    async connectToApp(appId) {\n      if (!this.webrtcClient) {\n        alert(\"WebRTC client not initialized\");\n        return;\n      }\n      try {\n        this.addLog(appId, \"Connecting...\", \"sent\");\n        await this.webrtcClient.connectToApp(appId);\n        this.addLog(appId, \"Connected successfully\", \"received\");\n      } catch (error) {\n        console.error(\"Failed to connect to app:\", error);\n        this.addLog(appId, \"Connection failed: \" + error, \"received\");\n        alert(\"Failed to connect to app: \" + error);\n      }\n    }\n    disconnectFromApp(appId) {\n      if (!this.webrtcClient) {\n        return;\n      }\n      this.webrtcClient.disconnect(appId);\n      this.addLog(appId, \"Disconnected\", \"sent\");\n      this.renderAppList();\n    }\n    handleSendMessage() {\n      const input = document.getElementById(\"message-input\");\n      const appSelect = document.getElementById(\"target-app\");\n      const message = input.value.trim();\n      const targetAppId = appSelect.value;\n      if (!message) {\n        alert(\"Please enter a message\");\n        return;\n      }\n      if (!targetAppId) {\n        alert(\"Please select a target app\");\n        return;\n      }\n      if (!this.webrtcClient) {\n        alert(\"WebRTC client not initialized\");\n        return;\n      }\n      try {\n        this.webrtcClient.sendMessage(targetAppId, message);\n        this.addLog(targetAppId, message, \"sent\");\n        input.value = \"\";\n      } catch (error) {\n        console.error(\"Failed to send message:\", error);\n        alert(\"Failed to send message: \" + error);\n      }\n    }\n    addLog(appId, data, direction) {\n      const entry = {\n        timestamp: /* @__PURE__ */ new Date(),\n        appId,\n        direction,\n        data\n      };\n      this.messageLog.push(entry);\n      if (this.messageLog.length > 100) {\n        this.messageLog.shift();\n      }\n      this.renderMessageLog();\n      this.updateTargetAppDropdown();\n    }\n    renderMessageLog() {\n      this.messageLogDiv.innerHTML = this.messageLog.slice().reverse().map((entry) => {\n        const time = entry.timestamp.toLocaleTimeString();\n        const directionClass = entry.direction === \"sent\" ? \"log-sent\" : \"log-received\";\n        const directionLabel = entry.direction === \"sent\" ? \"\\u2192\" : \"\\u2190\";\n        return `\n          <div class=\"log-entry ${directionClass}\">\n            <span class=\"log-time\">${time}</span>\n            <span class=\"log-direction\">${directionLabel}</span>\n            <span class=\"log-app\">${this.escapeHtml(entry.appId)}</span>\n            <span class=\"log-data\">${this.escapeHtml(entry.data)}</span>\n          </div>\n        `;\n      }).join(\"\");\n    }\n    updateTargetAppDropdown() {\n      const select = document.getElementById(\"target-app\");\n      const currentValue = select.value;\n      const connectedApps = this.webrtcClient?.getConnectedApps() || [];\n      select.innerHTML = '<option value=\"\">-- Select App --</option>' + connectedApps.map((appId) => {\n        const app = this.apps.get(appId);\n        const name = app ? app.name : appId;\n        return `<option value=\"${appId}\">${this.escapeHtml(name)}</option>`;\n      }).join(\"\");\n      if (connectedApps.includes(currentValue)) {\n        select.value = currentValue;\n      }\n    }\n    clearMessageLog() {\n      this.messageLog = [];\n      this.renderMessageLog();\n    }\n    escapeHtml(text) {\n      const div = document.createElement(\"div\");\n      div.textContent = text;\n      return div.innerHTML;\n    }\n  };\n  function initializeUI() {\n    if (document.readyState === \"loading\") {\n      document.addEventListener(\"DOMContentLoaded\", () => {\n        window.uiManager = new UIManager();\n      });\n    } else {\n      window.uiManager = new UIManager();\n    }\n  }\n  initializeUI();\n  return __toCommonJS(ui_exports);\n})();\n";
