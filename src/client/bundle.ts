// Auto-generated client bundle
// Run `npm run build:client` to regenerate

export const CLIENT_JS = `var m=Object.defineProperty;var C=(o,e,t)=>e in o?m(o,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):o[e]=t;var s=(o,e,t)=>C(o,typeof e!="symbol"?e+"":e,t);var c=class{constructor(e,t){s(this,"ws",null);s(this,"wsUrl");s(this,"token");s(this,"reconnectAttempts",0);s(this,"maxReconnectAttempts",10);s(this,"reconnectTimeout",null);s(this,"isManualDisconnect",!1);s(this,"isAuthenticated",!1);s(this,"onAuthenticated",null);s(this,"onAuthError",null);s(this,"onAppStatus",null);s(this,"onAppsListReceived",null);s(this,"onOffer",null);s(this,"onAnswer",null);s(this,"onIce",null);s(this,"onConnected",null);s(this,"onDisconnected",null);s(this,"onError",null);this.wsUrl=e,this.token=t}async connect(){if(!(this.ws?.readyState===WebSocket.OPEN||this.ws?.readyState===WebSocket.CONNECTING))return this.isManualDisconnect=!1,new Promise((e,t)=>{try{let i=new URL(this.wsUrl);i.searchParams.set("token",this.token),this.ws=new WebSocket(i.toString()),this.ws.onopen=()=>{this.reconnectAttempts=0,this.onConnected?.(),this.sendAuth(),e()},this.ws.onmessage=n=>{this.handleMessage(n.data)},this.ws.onerror=n=>{console.error("WebSocket error:",n),this.onError?.({message:"WebSocket error occurred"}),t(new Error("WebSocket connection error"))},this.ws.onclose=n=>{this.isAuthenticated=!1,this.onDisconnected?.(),this.isManualDisconnect||this.scheduleReconnect()}}catch(i){t(i)}})}disconnect(){this.isManualDisconnect=!0,this.isAuthenticated=!1,this.reconnectTimeout!==null&&(clearTimeout(this.reconnectTimeout),this.reconnectTimeout=null),this.ws&&(this.ws.close(),this.ws=null)}isConnected(){return this.ws?.readyState===WebSocket.OPEN&&this.isAuthenticated}sendAuth(){this.send({type:"auth",payload:{token:this.token}})}sendOffer(e,t){this.send({type:"offer",payload:{targetAppId:e,sdp:t}})}sendAnswer(e){this.send({type:"answer",payload:{sdp:e}})}sendIce(e,t){this.send({type:"ice",payload:{candidate:e,targetAppId:t}})}getApps(){this.send({type:"get_apps",payload:{}})}send(e){if(this.ws?.readyState!==WebSocket.OPEN){console.error("WebSocket is not open. Cannot send message:",e);return}try{this.ws.send(JSON.stringify(e))}catch(t){console.error("Failed to send message:",t),this.onError?.({message:"Failed to send message"})}}handleMessage(e){try{let t=JSON.parse(e);switch(t.type){case"auth_ok":this.isAuthenticated=!0,this.onAuthenticated?.(t.payload);break;case"auth_error":this.isAuthenticated=!1,this.onAuthError?.(t.payload);break;case"apps_list":this.onAppsListReceived?.(t.payload);break;case"app_status":this.onAppStatus?.(t.payload);break;case"offer":this.onOffer?.(t.payload);break;case"answer":this.onAnswer?.(t.payload);break;case"ice":this.onIce?.(t.payload);break;case"error":this.onError?.(t.payload);break;default:console.warn("Unknown message type:",t.type)}}catch(t){console.error("Failed to parse message:",t),this.onError?.({message:"Failed to parse server message"})}}scheduleReconnect(){if(this.reconnectAttempts>=this.maxReconnectAttempts){console.error("Max reconnection attempts reached"),this.onError?.({message:"Failed to reconnect after multiple attempts"});return}let e=Math.min(1e3*Math.pow(2,this.reconnectAttempts),3e4);this.reconnectAttempts++,console.log("Reconnecting in "+e+"ms (attempt "+this.reconnectAttempts+"/"+this.maxReconnectAttempts+")"),this.reconnectTimeout=window.setTimeout(()=>{this.connect().catch(t=>{console.error("Reconnection failed:",t)})},e)}updateToken(e){this.token=e,this.ws?.readyState===WebSocket.OPEN&&(this.disconnect(),this.connect().catch(t=>{console.error("Failed to reconnect with new token:",t)}))}};var v=[{urls:"stun:stun.l.google.com:19302"},{urls:"stun:stun1.l.google.com:19302"}],l=class{constructor(e,t=v){s(this,"signalingClient");s(this,"peerConnections",new Map);s(this,"iceServers");s(this,"onDataChannelOpen",null);s(this,"onDataChannelClose",null);s(this,"onDataChannelMessage",null);s(this,"onConnectionStateChange",null);s(this,"onError",null);this.signalingClient=e,this.iceServers=t,this.setupSignalingHandlers()}setupSignalingHandlers(){this.signalingClient.onAnswer=e=>{let{sdp:t,appId:i}=e;this.handleAnswer(i,t)},this.signalingClient.onIce=e=>{let{candidate:t,appId:i}=e;i&&this.handleIceCandidate(i,t)},this.signalingClient.onAppStatus=e=>{e.status==="offline"&&this.disconnect(e.appId)}}async connectToApp(e){if(this.peerConnections.has(e)){let a=this.peerConnections.get(e);if(a.dataChannel?.readyState==="open")return a.dataChannel;this.disconnect(e)}let t=new RTCPeerConnection({iceServers:this.iceServers}),i=t.createDataChannel("data",{ordered:!0}),n={pc:t,dataChannel:i,appId:e};this.peerConnections.set(e,n),this.setupPeerConnectionHandlers(e,t),this.setupDataChannelHandlers(e,i);try{let a=await t.createOffer();return await t.setLocalDescription(a),this.signalingClient.sendOffer(e,a.sdp),new Promise((r,p)=>{let h=setTimeout(()=>{p(new Error("Data channel connection timeout")),this.disconnect(e)},3e4);i.onopen=()=>{clearTimeout(h),this.onDataChannelOpen?.({appId:e}),r(i)},i.onerror=g=>{clearTimeout(h),this.onError?.({appId:e,message:"Data channel error: "+g}),p(g)}})}catch(a){throw this.disconnect(e),this.onError?.({appId:e,message:"Failed to create offer: "+a}),a}}disconnect(e){if(e){let t=this.peerConnections.get(e);t&&(this.closePeerConnection(t),this.peerConnections.delete(e))}else{for(let[t,i]of this.peerConnections.entries())this.closePeerConnection(i);this.peerConnections.clear()}}sendMessage(e,t){let i=this.peerConnections.get(e);if(!i?.dataChannel){this.onError?.({appId:e,message:"No data channel available for this app"});return}if(i.dataChannel.readyState!=="open"){this.onError?.({appId:e,message:"Data channel is not open (state: "+i.dataChannel.readyState+")"});return}try{i.dataChannel.send(t)}catch(n){this.onError?.({appId:e,message:"Failed to send message: "+n})}}getConnectionState(e){return this.peerConnections.get(e)?.pc.connectionState||null}getDataChannelState(e){return this.peerConnections.get(e)?.dataChannel?.readyState||null}getConnectedApps(){return Array.from(this.peerConnections.keys()).filter(e=>this.peerConnections.get(e)?.dataChannel?.readyState==="open")}async handleAnswer(e,t){let i=this.peerConnections.get(e);if(!i){console.warn("Received answer for unknown app: "+e);return}try{let n=new RTCSessionDescription({type:"answer",sdp:t});await i.pc.setRemoteDescription(n)}catch(n){this.onError?.({appId:e,message:"Failed to set remote description: "+n})}}async handleIceCandidate(e,t){let i=this.peerConnections.get(e);if(!i){console.warn("Received ICE candidate for unknown app: "+e);return}try{await i.pc.addIceCandidate(t)}catch(n){this.onError?.({appId:e,message:"Failed to add ICE candidate: "+n})}}setupPeerConnectionHandlers(e,t){t.onicecandidate=i=>{i.candidate&&this.signalingClient.sendIce(i.candidate,e)},t.onconnectionstatechange=()=>{let i=t.connectionState;this.onConnectionStateChange?.({appId:e,state:i}),(i==="failed"||i==="closed")&&this.disconnect(e)},t.oniceconnectionstatechange=()=>{let i=t.iceConnectionState;(i==="failed"||i==="closed")&&this.onError?.({appId:e,message:"ICE connection "+i})},t.ondatachannel=i=>{console.warn("Unexpected data channel from remote peer:",i.channel.label)}}setupDataChannelHandlers(e,t){t.onopen=()=>{this.onDataChannelOpen?.({appId:e})},t.onclose=()=>{this.onDataChannelClose?.({appId:e})},t.onmessage=i=>{this.onDataChannelMessage?.({appId:e,data:i.data})},t.onerror=i=>{this.onError?.({appId:e,message:"Data channel error: "+i})}}closePeerConnection(e){let{pc:t,dataChannel:i,appId:n}=e;if(i)try{i.close()}catch(a){console.error("Error closing data channel:",a)}try{t.close()}catch(a){console.error("Error closing peer connection:",a)}this.onDataChannelClose?.({appId:n})}};var d=class{constructor(){s(this,"signalingClient",null);s(this,"webrtcClient",null);s(this,"apps",new Map);s(this,"userInfo",null);s(this,"messageLog",[]);s(this,"loginSection");s(this,"userSection");s(this,"appListSection");s(this,"connectionSection");s(this,"messageSection");s(this,"userEmailSpan");s(this,"appListDiv");s(this,"messageLogDiv");s(this,"wsStatusSpan");s(this,"logoutBtn");this.initializeDOM(),this.checkAuthStatus()}initializeDOM(){this.loginSection=document.getElementById("login-section"),this.userSection=document.getElementById("user-section"),this.appListSection=document.getElementById("app-list-section"),this.connectionSection=document.getElementById("connection-section"),this.messageSection=document.getElementById("message-section"),this.userEmailSpan=document.getElementById("user-email"),this.appListDiv=document.getElementById("app-list"),this.messageLogDiv=document.getElementById("message-log"),this.wsStatusSpan=document.getElementById("ws-status"),this.logoutBtn=document.getElementById("logout-btn"),this.logoutBtn.addEventListener("click",()=>this.handleLogout()),document.getElementById("login-btn")?.addEventListener("click",()=>this.handleLogin()),document.getElementById("refresh-apps-btn")?.addEventListener("click",()=>this.refreshApps()),document.getElementById("send-message-btn")?.addEventListener("click",()=>this.handleSendMessage()),document.getElementById("clear-log-btn")?.addEventListener("click",()=>this.clearMessageLog())}async checkAuthStatus(){try{let e=this.getToken();if(!e){this.showLogin();return}let t=await fetch("/api/me",{headers:{Authorization:"Bearer "+e}});t.ok?(this.userInfo=await t.json(),this.showUserInterface(),this.initializeWebSocket(e)):(this.clearToken(),this.showLogin())}catch(e){console.error("Auth check failed:",e),this.showLogin()}}getToken(){let e=document.cookie.split(";");for(let t of e){let[i,n]=t.trim().split("=");if(i==="auth_token")return n}return localStorage.getItem("auth_token")}clearToken(){document.cookie="auth_token=; expires=Thu, 01 Jan 1970 00:00:00 UTC; path=/;",localStorage.removeItem("auth_token")}showLogin(){this.loginSection.style.display="block",this.userSection.style.display="none",this.appListSection.style.display="none",this.connectionSection.style.display="none",this.messageSection.style.display="none"}showUserInterface(){this.loginSection.style.display="none",this.userSection.style.display="block",this.appListSection.style.display="block",this.connectionSection.style.display="block",this.messageSection.style.display="block",this.userInfo&&(this.userEmailSpan.textContent=this.userInfo.email)}handleLogin(){window.location.href="/auth/login"}handleLogout(){this.clearToken(),this.signalingClient&&this.signalingClient.disconnect(),this.webrtcClient&&this.webrtcClient.disconnect(),this.showLogin()}async initializeWebSocket(e){let i=(window.location.protocol==="https:"?"wss:":"ws:")+"//"+window.location.host+"/ws";this.signalingClient=new c(i,e),this.signalingClient.onConnected=()=>{this.updateWSStatus("connected")},this.signalingClient.onDisconnected=()=>{this.updateWSStatus("disconnected")},this.signalingClient.onAuthenticated=n=>{console.log("Authenticated:",n),this.updateWSStatus("authenticated"),this.signalingClient?.getApps()},this.signalingClient.onAuthError=n=>{console.error("Auth error:",n),this.updateWSStatus("error"),alert("Authentication failed: "+n.error),this.handleLogout()},this.signalingClient.onAppsListReceived=n=>{console.log("Apps list received:",n),n.apps.forEach(a=>{this.apps.set(a.appId,{id:a.appId,name:a.name,capabilities:a.capabilities,status:a.status})}),this.renderAppList()},this.signalingClient.onAppStatus=n=>{console.log("App status update:",n);let a=this.apps.get(n.appId);a?(a.status=n.status,n.name&&(a.name=n.name),n.capabilities&&(a.capabilities=n.capabilities)):this.apps.set(n.appId,{id:n.appId,name:n.name||n.appId,capabilities:n.capabilities,status:n.status}),this.renderAppList()},this.signalingClient.onError=n=>{console.error("WebSocket error:",n),this.addLog("System","Error: "+n.message,"received")},this.webrtcClient=new l(this.signalingClient),this.webrtcClient.onDataChannelOpen=({appId:n})=>{console.log("Data channel opened:",n),this.addLog(n,"Connection established","received"),this.renderAppList()},this.webrtcClient.onDataChannelClose=({appId:n})=>{console.log("Data channel closed:",n),this.addLog(n,"Connection closed","received"),this.renderAppList()},this.webrtcClient.onDataChannelMessage=({appId:n,data:a})=>{console.log("Message from app:",n,a);let r=typeof a=="string"?a:"[Binary data: "+a.byteLength+" bytes]";this.addLog(n,r,"received")},this.webrtcClient.onConnectionStateChange=({appId:n,state:a})=>{console.log("Connection state change:",n,a),this.renderAppList()},this.webrtcClient.onError=({appId:n,message:a})=>{console.error("WebRTC error:",n,a),this.addLog(n||"System","Error: "+a,"received")};try{await this.signalingClient.connect()}catch(n){console.error("Failed to connect to WebSocket:",n),this.updateWSStatus("error")}}updateWSStatus(e){this.wsStatusSpan.textContent=e,this.wsStatusSpan.className="status-"+e}async refreshApps(){if(this.signalingClient?.isConnected())this.signalingClient.getApps();else try{let e=this.getToken(),t=await fetch("/api/apps",{headers:{Authorization:"Bearer "+e}});if(t.ok){let i=await t.json();this.apps.clear(),i.apps.forEach(n=>{this.apps.set(n.id,{id:n.id,name:n.name,capabilities:n.capabilities,status:"offline"})}),this.renderAppList()}}catch(e){console.error("Failed to fetch apps:",e)}}renderAppList(){let e=Array.from(this.apps.values());if(e.length===0){this.appListDiv.innerHTML='<p class="no-apps">No apps registered. Register an app to get started.</p>';return}this.appListDiv.innerHTML=e.map(t=>{let i=t.status==="online",n=this.webrtcClient?.getConnectionState(t.id),a=this.webrtcClient?.getDataChannelState(t.id),r=a==="open";return'<div class="app-card '+(i?"online":"offline")+'"><div class="app-header"><span class="app-name">'+this.escapeHtml(t.name)+'</span><span class="app-status '+(i?"status-online":"status-offline")+'">'+(i?"\\u25CF Online":"\\u25CB Offline")+'</span></div><div class="app-details"><div class="app-id">ID: '+this.escapeHtml(t.id)+'</div>'+(t.capabilities&&t.capabilities.length>0?'<div class="app-capabilities">Capabilities: '+t.capabilities.join(", ")+'</div>':'')+(n?'<div class="app-connection-state">WebRTC: '+n+'</div>':'')+(a?'<div class="app-datachannel-state">DataChannel: '+a+'</div>':'')+'</div><div class="app-actions">'+(i&&!r?'<button class="btn btn-primary" onclick="window.uiManager.connectToApp(\\''+t.id+'\\')">Connect</button>':'')+(r?'<button class="btn btn-danger" onclick="window.uiManager.disconnectFromApp(\\''+t.id+'\\')">Disconnect</button>':'')+'</div></div>'}).join("")}async connectToApp(e){if(!this.webrtcClient){alert("WebRTC client not initialized");return}try{this.addLog(e,"Connecting...","sent"),await this.webrtcClient.connectToApp(e),this.addLog(e,"Connected successfully","received")}catch(t){console.error("Failed to connect to app:",t),this.addLog(e,"Connection failed: "+t,"received"),alert("Failed to connect to app: "+t)}}disconnectFromApp(e){this.webrtcClient&&(this.webrtcClient.disconnect(e),this.addLog(e,"Disconnected","sent"),this.renderAppList())}handleSendMessage(){let e=document.getElementById("message-input"),t=document.getElementById("target-app"),i=e.value.trim(),n=t.value;if(!i){alert("Please enter a message");return}if(!n){alert("Please select a target app");return}if(!this.webrtcClient){alert("WebRTC client not initialized");return}try{this.webrtcClient.sendMessage(n,i),this.addLog(n,i,"sent"),e.value=""}catch(a){console.error("Failed to send message:",a),alert("Failed to send message: "+a)}}addLog(e,t,i){let n={timestamp:new Date,appId:e,direction:i,data:t};this.messageLog.push(n),this.messageLog.length>100&&this.messageLog.shift(),this.renderMessageLog(),this.updateTargetAppDropdown()}renderMessageLog(){this.messageLogDiv.innerHTML=this.messageLog.slice().reverse().map(e=>{let t=e.timestamp.toLocaleTimeString(),i=e.direction==="sent"?"log-sent":"log-received",n=e.direction==="sent"?"\\u2192":"\\u2190";return'<div class="log-entry '+i+'"><span class="log-time">'+t+'</span><span class="log-direction">'+n+'</span><span class="log-app">'+this.escapeHtml(e.appId)+'</span><span class="log-data">'+this.escapeHtml(e.data)+'</span></div>'}).join("")}updateTargetAppDropdown(){let e=document.getElementById("target-app"),t=e.value,i=this.webrtcClient?.getConnectedApps()||[];e.innerHTML='<option value="">-- Select App --</option>'+i.map(n=>{let a=this.apps.get(n),r=a?a.name:n;return'<option value="'+n+'">'+this.escapeHtml(r)+'</option>'}).join(""),i.includes(t)&&(e.value=t)}clearMessageLog(){this.messageLog=[],this.renderMessageLog()}escapeHtml(e){let t=document.createElement("div");return t.textContent=e,t.innerHTML}};function u(){document.readyState==="loading"?document.addEventListener("DOMContentLoaded",()=>{window.uiManager=new d}):window.uiManager=new d}u();export{c as SignalingClient,l as WebRTCClient,u as initializeUI};`;
