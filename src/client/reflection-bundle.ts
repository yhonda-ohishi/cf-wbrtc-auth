/**
 * Reflection UI Bundle - Built from reflection-ui.ts
 *
 * To update: Run `npm run build:reflection-client`
 */

export const REFLECTION_CLIENT_JS = `"use strict";(()=>{var L=Object.defineProperty;var M=(i,e,n)=>e in i?L(i,e,{enumerable:!0,configurable:!0,writable:!0,value:n}):i[e]=n;var r=(i,e,n)=>M(i,typeof e!="symbol"?e+"":e,n);var m=class{constructor(e,n=null){r(this,"ws",null);r(this,"wsUrl");r(this,"token");r(this,"reconnectAttempts",0);r(this,"maxReconnectAttempts",10);r(this,"reconnectTimeout",null);r(this,"isManualDisconnect",!1);r(this,"isAuthenticated",!1);r(this,"onAuthenticated",null);r(this,"onAuthError",null);r(this,"onAppStatus",null);r(this,"onAppsListReceived",null);r(this,"onOffer",null);r(this,"onAnswer",null);r(this,"onIce",null);r(this,"onConnected",null);r(this,"onDisconnected",null);r(this,"onError",null);this.wsUrl=e,this.token=n}async connect(){if(!(this.ws?.readyState===WebSocket.OPEN||this.ws?.readyState===WebSocket.CONNECTING))return this.isManualDisconnect=!1,new Promise((e,n)=>{try{let t=new URL(this.wsUrl);this.token&&t.searchParams.set("token",this.token),this.ws=new WebSocket(t.toString()),this.ws.onopen=()=>{this.reconnectAttempts=0,this.onConnected?.(),this.sendAuth(),e()},this.ws.onmessage=s=>{this.handleMessage(s.data)},this.ws.onerror=s=>{console.error("WebSocket error:",s),this.onError?.({message:"WebSocket error occurred"}),n(new Error("WebSocket connection error"))},this.ws.onclose=s=>{this.isAuthenticated=!1,this.onDisconnected?.(),this.isManualDisconnect||this.scheduleReconnect()}}catch(t){n(t)}})}disconnect(){this.isManualDisconnect=!0,this.isAuthenticated=!1,this.reconnectTimeout!==null&&(clearTimeout(this.reconnectTimeout),this.reconnectTimeout=null),this.ws&&(this.ws.close(),this.ws=null)}isConnected(){return this.ws?.readyState===WebSocket.OPEN&&this.isAuthenticated}sendAuth(){this.send({type:"auth",payload:{token:this.token}})}sendOffer(e,n){this.send({type:"offer",payload:{targetAppId:e,sdp:n}})}sendAnswer(e){this.send({type:"answer",payload:{sdp:e}})}sendIce(e,n){this.send({type:"ice",payload:{candidate:e,targetAppId:n}})}getApps(){this.send({type:"get_apps",payload:{}})}send(e){if(this.ws?.readyState!==WebSocket.OPEN){console.error("WebSocket is not open. Cannot send message:",e);return}try{this.ws.send(JSON.stringify(e))}catch(n){console.error("Failed to send message:",n),this.onError?.({message:"Failed to send message"})}}handleMessage(e){try{let n=JSON.parse(e);switch(n.type){case"auth_ok":this.isAuthenticated=!0,this.onAuthenticated?.(n.payload);break;case"auth_error":this.isAuthenticated=!1,this.onAuthError?.(n.payload);break;case"apps_list":this.onAppsListReceived?.(n.payload);break;case"app_status":this.onAppStatus?.(n.payload);break;case"offer":this.onOffer?.(n.payload);break;case"answer":this.onAnswer?.(n.payload);break;case"ice":this.onIce?.(n.payload);break;case"error":this.onError?.(n.payload);break;default:console.warn("Unknown message type:",n.type)}}catch(n){console.error("Failed to parse message:",n),this.onError?.({message:"Failed to parse server message"})}}scheduleReconnect(){if(this.reconnectAttempts>=this.maxReconnectAttempts){console.error("Max reconnection attempts reached"),this.onError?.({message:"Failed to reconnect after multiple attempts"});return}let e=Math.min(1e3*Math.pow(2,this.reconnectAttempts),3e4);this.reconnectAttempts++,console.log(\`Reconnecting in \${e}ms (attempt \${this.reconnectAttempts}/\${this.maxReconnectAttempts})\`),this.reconnectTimeout=window.setTimeout(()=>{this.connect().catch(n=>{console.error("Reconnection failed:",n)})},e)}updateToken(e){this.token=e,this.ws?.readyState===WebSocket.OPEN&&(this.disconnect(),this.connect().catch(n=>{console.error("Failed to reconnect with new token:",n)}))}};function R(i){let e=i.data.length,n=new Uint8Array(5+e);return n[0]=i.flags,new DataView(n.buffer).setUint32(1,e,!1),n.set(i.data,5),n}function A(i){let e=[],n=0;for(;n<i.length;){if(n+5>i.length)return{frames:e,remaining:i.slice(n)};let t=i[n],o=new DataView(i.buffer,i.byteOffset+n+1,4).getUint32(0,!1),a=n+5+o;if(a>i.length)return{frames:e,remaining:i.slice(n)};let l=i.slice(n+5,a);e.push({flags:t,data:l}),n=a}return{frames:e,remaining:new Uint8Array(0)}}function b(i){return{flags:0,data:i}}function T(i){let n=new TextDecoder("utf-8").decode(i),t={},s=n.split(\`\\r
`+String.raw`\`);for(let o of s){if(!o.trim())continue;let a=o.indexOf(":");if(a===-1)continue;let l=o.substring(0,a).trim().toLowerCase(),c=o.substring(a+1).trim();t[l]=c}return t}var y={OK:0,CANCELLED:1,UNKNOWN:2,INVALID_ARGUMENT:3,DEADLINE_EXCEEDED:4,NOT_FOUND:5,ALREADY_EXISTS:6,PERMISSION_DENIED:7,RESOURCE_EXHAUSTED:8,FAILED_PRECONDITION:9,ABORTED:10,OUT_OF_RANGE:11,UNIMPLEMENTED:12,INTERNAL:13,UNAVAILABLE:14,DATA_LOSS:15,UNAUTHENTICATED:16};function D(i){let e=new TextEncoder,n=e.encode(i.path),t=n.length,s=JSON.stringify(i.headers),o=e.encode(s),a=o.length,l=b(i.message),c=R(l),h=4+t+4+a+c.length,d=new Uint8Array(h),u=new DataView(d.buffer),p=0;return u.setUint32(p,t,!1),p+=4,d.set(n,p),p+=t,u.setUint32(p,a,!1),p+=4,d.set(o,p),p+=a,d.set(c,p),d}function I(i){let e=new TextDecoder("utf-8"),n=new DataView(i.buffer,i.byteOffset),t=0;if(t+4>i.length)throw new Error("Incomplete response: missing headers length");let s=n.getUint32(t,!1);if(t+=4,t+s>i.length)throw new Error("Incomplete response: missing headers");let o=i.slice(t,t+s),a=e.decode(o),l=JSON.parse(a);t+=s;let c=i.slice(t),{frames:h,remaining:d}=A(c);if(d.length>0)throw new Error("Incomplete response: partial frame remaining");let u=[],p={};for(let g of h)if(g.flags===0)u.push(g.data);else if(g.flags===1)p=T(g.data);else throw new Error(\`Unknown frame flags: \${g.flags}\`);return{headers:l,messages:u,trailers:p}}function S(i){let e=i.trailers["grpc-status"];return e?parseInt(e,10)!==y.OK:!1}function k(i){if(!S(i))return null;let e=parseInt(i.trailers["grpc-status"]||"2",10),n=i.trailers["grpc-message"]||"Unknown error";return{code:e,message:n}}var f=class extends Error{constructor(n,t,s){super(t);this.code=n;this.trailers=s;this.name="GrpcError"}},v=class{constructor(e){r(this,"dataChannel");r(this,"pendingRequests",new Map);r(this,"requestIdCounter",0);r(this,"closed",!1);this.dataChannel=e,this.dataChannel.binaryType="arraybuffer",this.dataChannel.addEventListener("message",this.handleMessage.bind(this)),this.dataChannel.addEventListener("close",this.handleClose.bind(this)),this.dataChannel.addEventListener("error",this.handleError.bind(this))}async unary(e,n,t,s,o){let a=t(n),c={"x-request-id":this.generateRequestId(),...o?.headers||{}},h={path:e,headers:c,message:a},d=await this.call(h,o);if(d.messages.length===0)throw new Error("No response message received for unary call");if(d.messages.length>1)throw new Error(\`Expected single response message, got \${d.messages.length}\`);return{message:s(d.messages[0]),headers:d.headers,trailers:d.trailers}}async call(e,n){if(this.closed)throw new Error("Transport is closed");let t=e.headers["x-request-id"];if(!t)throw new Error("Request envelope must include x-request-id header");let s=n?.timeout||3e4,o=new Promise((c,h)=>{let d=setTimeout(()=>{this.pendingRequests.delete(t),h(new Error(\`Request timeout after \${s}ms\`))},s);this.pendingRequests.set(t,{resolve:c,reject:h,timeout:d})}),a=D(e);try{this.dataChannel.send(a)}catch(c){let h=this.pendingRequests.get(t);throw h&&(clearTimeout(h.timeout),this.pendingRequests.delete(t)),c}let l=await o;if(S(l)){let c=k(l);throw c?new f(c.code,c.message,l.trailers):new f(y.UNKNOWN,"Unknown error",l.trailers)}return l}close(){if(this.closed)return;this.closed=!0;let e=new Error("Transport closed");for(let[n,t]of this.pendingRequests.entries())clearTimeout(t.timeout),t.reject(e);this.pendingRequests.clear(),this.dataChannel.readyState==="open"&&this.dataChannel.close(),this.dataChannel.removeEventListener("message",this.handleMessage.bind(this)),this.dataChannel.removeEventListener("close",this.handleClose.bind(this)),this.dataChannel.removeEventListener("error",this.handleError.bind(this))}generateRequestId(){return this.requestIdCounter++,\`req-\${Date.now()}-\${this.requestIdCounter}\`}handleMessage(e){if(this.closed)return;let n=new Uint8Array(e.data);try{let t=I(n),s=t.headers["x-request-id"];if(!s){console.error("Received response without x-request-id header");return}let o=this.pendingRequests.get(s);if(!o){console.warn(\`Received response for unknown request ID: \${s}\`);return}clearTimeout(o.timeout),this.pendingRequests.delete(s),o.resolve(t)}catch(t){console.error("Failed to decode response:",t)}}handleClose(){if(this.closed)return;let e=new Error("DataChannel closed");for(let[n,t]of this.pendingRequests.entries())clearTimeout(t.timeout),t.reject(e);this.pendingRequests.clear(),this.closed=!0}handleError(e){console.error("DataChannel error:",e)}get channel(){return this.dataChannel}get isClosed(){return this.closed}get pendingCount(){return this.pendingRequests.size}};var U=[{urls:"stun:stun.l.google.com:19302"},{urls:"stun:stun1.l.google.com:19302"}],C=class{constructor(e,n=U){r(this,"signalingClient");r(this,"peerConnections",new Map);r(this,"iceServers");r(this,"onDataChannelOpen",null);r(this,"onDataChannelClose",null);r(this,"onDataChannelMessage",null);r(this,"onConnectionStateChange",null);r(this,"onError",null);this.signalingClient=e,this.iceServers=n,this.setupSignalingHandlers()}setupSignalingHandlers(){this.signalingClient.onAnswer=e=>{let{sdp:n,appId:t}=e;this.handleAnswer(t,n)},this.signalingClient.onIce=e=>{let{candidate:n,appId:t}=e;t&&this.handleIceCandidate(t,n)},this.signalingClient.onAppStatus=e=>{e.status==="offline"&&this.disconnect(e.appId)}}async connectToApp(e){if(this.peerConnections.has(e)){let o=this.peerConnections.get(e);if(o.dataChannel?.readyState==="open")return o.dataChannel;this.disconnect(e)}let n=new RTCPeerConnection({iceServers:this.iceServers}),t=n.createDataChannel("data",{ordered:!0}),s={pc:n,dataChannel:t,transport:null,appId:e};this.peerConnections.set(e,s),this.setupPeerConnectionHandlers(e,n),this.setupDataChannelHandlers(e,t);try{let o=await n.createOffer();return await n.setLocalDescription(o),this.signalingClient.sendOffer(e,o.sdp),new Promise((a,l)=>{let c=setTimeout(()=>{l(new Error("Data channel connection timeout")),this.disconnect(e)},3e4);t.onopen=()=>{clearTimeout(c),s.transport=new v(t),this.onDataChannelOpen?.({appId:e}),a(t)},t.onerror=h=>{clearTimeout(c),this.onError?.({appId:e,message:\`Data channel error: \${h}\`}),l(h)}})}catch(o){throw this.disconnect(e),this.onError?.({appId:e,message:\`Failed to create offer: \${o}\`}),o}}disconnect(e){if(e){let n=this.peerConnections.get(e);n&&(this.closePeerConnection(n),this.peerConnections.delete(e))}else{for(let[n,t]of this.peerConnections.entries())this.closePeerConnection(t);this.peerConnections.clear()}}sendMessage(e,n){let t=this.peerConnections.get(e);if(!t?.dataChannel){this.onError?.({appId:e,message:"No data channel available for this app"});return}if(t.dataChannel.readyState!=="open"){this.onError?.({appId:e,message:\`Data channel is not open (state: \${t.dataChannel.readyState})\`});return}try{t.dataChannel.send(n)}catch(s){this.onError?.({appId:e,message:\`Failed to send message: \${s}\`})}}getConnectionState(e){return this.peerConnections.get(e)?.pc.connectionState||null}getDataChannelState(e){return this.peerConnections.get(e)?.dataChannel?.readyState||null}getConnectedApps(){return Array.from(this.peerConnections.keys()).filter(e=>this.peerConnections.get(e)?.dataChannel?.readyState==="open")}getTransport(e){return this.peerConnections.get(e)?.transport||null}getDataChannel(e){return this.peerConnections.get(e)?.dataChannel||null}async handleAnswer(e,n){let t=this.peerConnections.get(e);if(!t){console.warn(\`Received answer for unknown app: \${e}\`);return}try{let s=new RTCSessionDescription({type:"answer",sdp:n});await t.pc.setRemoteDescription(s)}catch(s){this.onError?.({appId:e,message:\`Failed to set remote description: \${s}\`})}}async handleIceCandidate(e,n){let t=this.peerConnections.get(e);if(!t){console.warn(\`Received ICE candidate for unknown app: \${e}\`);return}try{await t.pc.addIceCandidate(n)}catch(s){this.onError?.({appId:e,message:\`Failed to add ICE candidate: \${s}\`})}}setupPeerConnectionHandlers(e,n){n.onicecandidate=t=>{t.candidate&&this.signalingClient.sendIce(t.candidate,e)},n.onconnectionstatechange=()=>{let t=n.connectionState;this.onConnectionStateChange?.({appId:e,state:t}),(t==="failed"||t==="closed")&&this.disconnect(e)},n.oniceconnectionstatechange=()=>{let t=n.iceConnectionState;(t==="failed"||t==="closed")&&this.onError?.({appId:e,message:\`ICE connection \${t}\`})},n.ondatachannel=t=>{console.warn("Unexpected data channel from remote peer:",t.channel.label)}}setupDataChannelHandlers(e,n){n.onopen=()=>{this.onDataChannelOpen?.({appId:e})},n.onclose=()=>{this.onDataChannelClose?.({appId:e})},n.onmessage=t=>{this.onDataChannelMessage?.({appId:e,data:t.data})},n.onerror=t=>{this.onError?.({appId:e,message:\`Data channel error: \${t}\`})}}closePeerConnection(e){let{pc:n,dataChannel:t,transport:s,appId:o}=e;if(s)try{s.close()}catch(a){console.error("Error closing transport:",a)}if(t)try{t.close()}catch(a){console.error("Error closing data channel:",a)}try{n.close()}catch(a){console.error("Error closing peer connection:",a)}this.onDataChannelClose?.({appId:o})}};var x="/grpc.reflection.v1alpha.ServerReflection/ListServices",E=class{constructor(e){r(this,"transport");this.transport=e}async listServices(e){return(await this.transport.unary(x,new Uint8Array(0),t=>t,t=>{let s=new TextDecoder().decode(t);return JSON.parse(s)},e)).message}static getMethodPath(e,n){return\`/\${e}/\${n}\`}};var w=class{constructor(){r(this,"signalingClient",null);r(this,"webrtcClient",null);r(this,"reflectionClient",null);r(this,"apps",new Map);r(this,"userInfo",null);r(this,"connectedAppId",null);r(this,"loginSection");r(this,"userSection");r(this,"appListSection");r(this,"reflectionSection");r(this,"userEmailSpan");r(this,"appSelectElement");r(this,"wsStatusSpan");r(this,"logoutBtn");r(this,"connectBtn");r(this,"resultsDiv");r(this,"statusDiv");this.initializeDOM(),this.checkAuthStatus()}initializeDOM(){this.loginSection=document.getElementById("login-section"),this.userSection=document.getElementById("user-section"),this.appListSection=document.getElementById("app-list-section"),this.reflectionSection=document.getElementById("reflection-section"),this.userEmailSpan=document.getElementById("user-email"),this.appSelectElement=document.getElementById("app-select"),this.wsStatusSpan=document.getElementById("ws-status"),this.logoutBtn=document.getElementById("logout-btn"),this.connectBtn=document.getElementById("connect-btn"),this.resultsDiv=document.getElementById("results"),this.statusDiv=document.getElementById("status"),this.logoutBtn.addEventListener("click",()=>this.handleLogout()),document.getElementById("login-btn")?.addEventListener("click",()=>this.handleLogin()),this.connectBtn.addEventListener("click",()=>this.handleConnectAndList())}async checkAuthStatus(){try{let e=await fetch("/api/me");e.ok?(this.userInfo=await e.json(),this.showUserInterface(),this.initializeWebSocket()):this.showLogin()}catch(e){console.error("Auth check failed:",e),this.showLogin()}}clearToken(){document.cookie="token=; expires=Thu, 01 Jan 1970 00:00:00 UTC; path=/;",localStorage.removeItem("token")}showLogin(){this.loginSection.style.display="block",this.userSection.style.display="none",this.appListSection.style.display="none",this.reflectionSection.style.display="none"}showUserInterface(){this.loginSection.style.display="none",this.userSection.style.display="block",this.appListSection.style.display="block",this.reflectionSection.style.display="block",this.userInfo&&(this.userEmailSpan.textContent=this.userInfo.email)}handleLogin(){window.location.href="/auth/login"}handleLogout(){this.clearToken(),this.signalingClient&&this.signalingClient.disconnect(),this.webrtcClient&&this.webrtcClient.disconnect(),this.showLogin()}async initializeWebSocket(){let n=\`\${window.location.protocol==="https:"?"wss:":"ws:"}\${"//\${window.location.host}/ws"}\`;this.signalingClient=new m(n),this.signalingClient.onConnected=()=>{this.updateWSStatus("connected")},this.signalingClient.onDisconnected=()=>{this.updateWSStatus("disconnected")},this.signalingClient.onAuthenticated=t=>{console.log("Authenticated:",t),this.updateWSStatus("authenticated"),this.signalingClient?.getApps()},this.signalingClient.onAuthError=t=>{console.error("Auth error:",t),this.updateWSStatus("error"),alert("Authentication failed: "+t.error),this.handleLogout()},this.signalingClient.onAppsListReceived=t=>{console.log("Apps list received:",t),t.apps.forEach(s=>{this.apps.set(s.appId,{id:s.appId,name:s.name,capabilities:s.capabilities,status:s.status})}),this.renderAppList()},this.signalingClient.onAppStatus=t=>{console.log("App status update:",t);let s=this.apps.get(t.appId);s?(s.status=t.status,t.name&&(s.name=t.name),t.capabilities&&(s.capabilities=t.capabilities)):this.apps.set(t.appId,{id:t.appId,name:t.name||t.appId,capabilities:t.capabilities,status:t.status}),this.renderAppList()},this.signalingClient.onError=t=>{console.error("WebSocket error:",t),this.setStatus("Error: "+t.message,"error")},this.webrtcClient=new C(this.signalingClient),this.webrtcClient.onDataChannelOpen=({appId:t})=>{console.log("Data channel opened:",t),this.setStatus("Connected to "+t,"success")},this.webrtcClient.onDataChannelClose=({appId:t})=>{console.log("Data channel closed:",t),this.setStatus("Disconnected from "+t,"info"),this.connectedAppId===t&&(this.connectedAppId=null,this.reflectionClient=null)},this.webrtcClient.onError=({appId:t,message:s})=>{console.error("WebRTC error:",t,s),this.setStatus("Error: "+s,"error")};try{await this.signalingClient.connect()}catch(t){console.error("Failed to connect to WebSocket:",t),this.updateWSStatus("error")}}updateWSStatus(e){this.wsStatusSpan.textContent=e,this.wsStatusSpan.className=\`status-\${e}\`}renderAppList(){let e=Array.from(this.apps.values()).filter(n=>n.status==="online");this.appSelectElement.innerHTML='<option value="">-- Select an Online App --</option>'+e.map(n=>\`<option value="\${n.id}">\${this.escapeHtml(n.name)} (\${this.escapeHtml(n.id)})</option>\`).join(""),this.connectBtn.disabled=e.length===0}async handleConnectAndList(){let e=this.appSelectElement.value;if(!e){alert("Please select an app");return}if(!this.webrtcClient){alert("WebRTC client not initialized");return}try{this.setStatus("Connecting to app...","info"),this.connectBtn.disabled=!0,await this.webrtcClient.connectToApp(e),this.connectedAppId=e,this.setStatus("Connected! Listing services...","info");let n=this.webrtcClient.getTransport(e);if(!n)throw new Error("Failed to get transport");this.reflectionClient=new E(n);let t=await this.reflectionClient.listServices({timeout:1e4});this.displayResults(t),this.setStatus("Services listed successfully","success")}catch(n){console.error("Failed to connect or list services:",n),this.setStatus("Error: "+n,"error"),alert("Failed to list services: "+n)}finally{this.connectBtn.disabled=!1}}displayResults(e){if(!e.services||e.services.length===0){this.resultsDiv.innerHTML='<div class="no-results">No services found</div>';return}let n=e.services.map(t=>{let s=t.methods&&t.methods.length>0?\`<ul class="methods-list">
            \${t.methods.map(o=>\`<li class="method-item">\${this.escapeHtml(o)}</li>\`).join("")}
          </ul>\`:'<div class="no-methods">No methods</div>';return\`
        <div class="service-card">
          <div class="service-name">\${this.escapeHtml(t.name)}</div>
          <div class="service-methods">
            <div class="methods-header">Methods:</div>
            \${s}
          </div>
        </div>
      \`}).join("");this.resultsDiv.innerHTML=\`
      <div class="results-header">Found \${e.services.length} service(s)</div>
      <div class="services-container">\${n}</div>
      <div class="results-footer">
        <button class="btn btn-secondary" onclick="window.reflectionUI.showRawJSON()">
          Show Raw JSON
        </button>
      </div>
    \`,window.reflectionResponse=e}showRawJSON(){let e=window.reflectionResponse;if(!e){alert("No response data available");return}let n=JSON.stringify(e,null,2);this.resultsDiv.innerHTML=\`
      <div class="results-header">Raw JSON Response</div>
      <pre class="raw-json">\${this.escapeHtml(n)}</pre>
      <div class="results-footer">
        <button class="btn btn-secondary" onclick="location.reload()">
          Refresh Page
        </button>
      </div>
    \`}setStatus(e,n){this.statusDiv.textContent=e,this.statusDiv.className=\`status-message status-\${n}\`,this.statusDiv.style.display="block"}escapeHtml(e){let n=document.createElement("div");return n.textContent=e,n.innerHTML}};function N(){document.readyState==="loading"?document.addEventListener("DOMContentLoaded",()=>{window.reflectionUI=new w}):window.reflectionUI=new w}N();})();
`;
