"use strict";(()=>{var J=Object.defineProperty;var j=(s,e,n)=>e in s?J(s,e,{enumerable:!0,configurable:!0,writable:!0,value:n}):s[e]=n;var i=(s,e,n)=>j(s,typeof e!="symbol"?e+"":e,n);var y=class{constructor(e,n=null){i(this,"ws",null);i(this,"wsUrl");i(this,"token");i(this,"reconnectAttempts",0);i(this,"maxReconnectAttempts",10);i(this,"reconnectTimeout",null);i(this,"isManualDisconnect",!1);i(this,"isAuthenticated",!1);i(this,"onAuthenticated",null);i(this,"onAuthError",null);i(this,"onAppStatus",null);i(this,"onAppsListReceived",null);i(this,"onOffer",null);i(this,"onAnswer",null);i(this,"onIce",null);i(this,"onConnected",null);i(this,"onDisconnected",null);i(this,"onError",null);this.wsUrl=e,this.token=n}async connect(){if(!(this.ws?.readyState===WebSocket.OPEN||this.ws?.readyState===WebSocket.CONNECTING))return this.isManualDisconnect=!1,new Promise((e,n)=>{try{let t=new URL(this.wsUrl);this.token&&t.searchParams.set("token",this.token),this.ws=new WebSocket(t.toString()),this.ws.onopen=()=>{this.reconnectAttempts=0,this.onConnected?.(),this.sendAuth(),e()},this.ws.onmessage=r=>{this.handleMessage(r.data)},this.ws.onerror=r=>{console.error("WebSocket error:",r),this.onError?.({message:"WebSocket error occurred"}),n(new Error("WebSocket connection error"))},this.ws.onclose=r=>{this.isAuthenticated=!1,this.onDisconnected?.(),this.isManualDisconnect||this.scheduleReconnect()}}catch(t){n(t)}})}disconnect(){this.isManualDisconnect=!0,this.isAuthenticated=!1,this.reconnectTimeout!==null&&(clearTimeout(this.reconnectTimeout),this.reconnectTimeout=null),this.ws&&(this.ws.close(),this.ws=null)}isConnected(){return this.ws?.readyState===WebSocket.OPEN&&this.isAuthenticated}sendAuth(){this.send({type:"auth",payload:{token:this.token}})}sendOffer(e,n){this.send({type:"offer",payload:{targetAppId:e,sdp:n}})}sendAnswer(e){this.send({type:"answer",payload:{sdp:e}})}sendIce(e,n){this.send({type:"ice",payload:{candidate:e,targetAppId:n}})}getApps(){this.send({type:"get_apps",payload:{}})}send(e){if(this.ws?.readyState!==WebSocket.OPEN){console.error("WebSocket is not open. Cannot send message:",e);return}try{this.ws.send(JSON.stringify(e))}catch(n){console.error("Failed to send message:",n),this.onError?.({message:"Failed to send message"})}}handleMessage(e){try{let n=JSON.parse(e);switch(n.type){case"auth_ok":this.isAuthenticated=!0,this.onAuthenticated?.(n.payload);break;case"auth_error":this.isAuthenticated=!1,this.onAuthError?.(n.payload);break;case"apps_list":this.onAppsListReceived?.(n.payload);break;case"app_status":this.onAppStatus?.(n.payload);break;case"offer":this.onOffer?.(n.payload);break;case"answer":this.onAnswer?.(n.payload);break;case"ice":this.onIce?.(n.payload);break;case"error":this.onError?.(n.payload);break;default:console.warn("Unknown message type:",n.type)}}catch(n){console.error("Failed to parse message:",n),this.onError?.({message:"Failed to parse server message"})}}scheduleReconnect(){if(this.reconnectAttempts>=this.maxReconnectAttempts){console.error("Max reconnection attempts reached"),this.onError?.({message:"Failed to reconnect after multiple attempts"});return}let e=Math.min(1e3*Math.pow(2,this.reconnectAttempts),3e4);this.reconnectAttempts++,console.log(`Reconnecting in ${e}ms (attempt ${this.reconnectAttempts}/${this.maxReconnectAttempts})`),this.reconnectTimeout=window.setTimeout(()=>{this.connect().catch(n=>{console.error("Reconnection failed:",n)})},e)}updateToken(e){this.token=e,this.ws?.readyState===WebSocket.OPEN&&(this.disconnect(),this.connect().catch(n=>{console.error("Failed to reconnect with new token:",n)}))}};function P(s){let e=s.data.length,n=new Uint8Array(5+e);return n[0]=s.flags,new DataView(n.buffer).setUint32(1,e,!1),n.set(s.data,5),n}function S(s){let e=[],n=0;for(;n<s.length;){if(n+5>s.length)return{frames:e,remaining:s.slice(n)};let t=s[n],o=new DataView(s.buffer,s.byteOffset+n+1,4).getUint32(0,!1),c=n+5+o;if(c>s.length)return{frames:e,remaining:s.slice(n)};let l=s.slice(n+5,c);e.push({flags:t,data:l}),n=c}return{frames:e,remaining:new Uint8Array(0)}}function N(s){return{flags:0,data:s}}function b(s){let n=new TextDecoder("utf-8").decode(s),t={},r=n.split(`\r
`);for(let o of r){if(!o.trim())continue;let c=o.indexOf(":");if(c===-1)continue;let l=o.substring(0,c).trim().toLowerCase(),h=o.substring(c+1).trim();t[l]=h}return t}var T={OK:0,CANCELLED:1,UNKNOWN:2,INVALID_ARGUMENT:3,DEADLINE_EXCEEDED:4,NOT_FOUND:5,ALREADY_EXISTS:6,PERMISSION_DENIED:7,RESOURCE_EXHAUSTED:8,FAILED_PRECONDITION:9,ABORTED:10,OUT_OF_RANGE:11,UNIMPLEMENTED:12,INTERNAL:13,UNAVAILABLE:14,DATA_LOSS:15,UNAUTHENTICATED:16};function U(s){let e=new TextEncoder,n=e.encode(s.path),t=n.length,r=JSON.stringify(s.headers),o=e.encode(r),c=o.length,l=N(s.message),h=P(l),p=4+t+4+c+h.length,u=new Uint8Array(p),f=new DataView(u.buffer),d=0;return f.setUint32(d,t,!1),d+=4,u.set(n,d),d+=t,f.setUint32(d,c,!1),d+=4,u.set(o,d),d+=c,u.set(h,d),u}function F(s){let e=new TextDecoder("utf-8"),n=new DataView(s.buffer,s.byteOffset),t=0;if(t+4>s.length)throw new Error("Incomplete response: missing headers length");let r=n.getUint32(t,!1);if(t+=4,t+r>s.length)throw new Error("Incomplete response: missing headers");let o=s.slice(t,t+r),c=e.decode(o),l=JSON.parse(c);t+=r;let h=s.slice(t),{frames:p,remaining:u}=S(h);if(u.length>0)throw new Error("Incomplete response: partial frame remaining");let f=[],d={};for(let v of p)if(v.flags===0)f.push(v.data);else if(v.flags===1)d=b(v.data);else throw new Error(`Unknown frame flags: ${v.flags}`);return{headers:l,messages:f,trailers:d}}function x(s){let e=s.trailers["grpc-status"];return e?parseInt(e,10)!==T.OK:!1}function W(s){if(!x(s))return null;let e=parseInt(s.trailers["grpc-status"]||"2",10),n=s.trailers["grpc-message"]||"Unknown error";return{code:e,message:n}}var w={DATA:0,END:1};function B(s){let e=new DataView(s.buffer,s.byteOffset),n=new TextDecoder("utf-8"),t=0;if(t+4>s.length)throw new Error("Stream message too short");let r=e.getUint32(t,!1);if(t+=4,t+r+1>s.length)throw new Error("Incomplete stream message");let o=n.decode(s.slice(t,t+r));t+=r;let c=s[t];t++;let l=s.slice(t);return{requestId:o,flag:c,data:l}}function H(s){if(s.length<5)return!1;let n=new DataView(s.buffer,s.byteOffset).getUint32(0,!1);if(n===0||n>s.length-4||s[4]===123)return!1;if(n>=4&&4+n+1<=s.length&&String.fromCharCode(s[4],s[5],s[6],s[7])==="req-"){let o=s[4+n];return o===w.DATA||o===w.END}return!1}var R=class extends Error{constructor(n,t,r){super(t);this.code=n;this.trailers=r;this.name="GrpcError"}},D=class{constructor(e){i(this,"dataChannel");i(this,"pendingRequests",new Map);i(this,"pendingStreamRequests",new Map);i(this,"requestIdCounter",0);i(this,"closed",!1);this.dataChannel=e,this.dataChannel.binaryType="arraybuffer",this.dataChannel.addEventListener("message",this.handleMessage.bind(this)),this.dataChannel.addEventListener("close",this.handleClose.bind(this)),this.dataChannel.addEventListener("error",this.handleError.bind(this))}async unary(e,n,t,r,o){let c=t(n),h={"x-request-id":this.generateRequestId(),...o?.headers||{}},p={path:e,headers:h,message:c},u=await this.call(p,o);if(u.messages.length===0)throw new Error("No response message received for unary call");if(u.messages.length>1)throw new Error(`Expected single response message, got ${u.messages.length}`);return{message:r(u.messages[0]),headers:u.headers,trailers:u.trailers}}serverStreaming(e,n,t,r,o){if(this.closed)throw new Error("Transport is closed");let c=t(n),l=this.generateRequestId(),h={"x-request-id":l,...o?.headers||{}},p={path:e,headers:h,message:c},u=o?.timeout||3e4,f=[],d=null,v=!1,C=null,O={},A=setTimeout(()=>{this.pendingStreamRequests.delete(l),C=new Error(`Request timeout after ${u}ms`),v=!0,d&&d({done:!0,value:void 0})},u);this.pendingStreamRequests.set(l,{onMessage:g=>{try{let m=r(g);if(d){let E=d;d=null,E({done:!1,value:m})}else f.push(m)}catch(m){C=m instanceof Error?m:new Error(String(m))}},onEnd:g=>{clearTimeout(A),O=g,v=!0;let m=g["grpc-status"];if(m&&parseInt(m,10)!==T.OK){let E=parseInt(m,10),z=g["grpc-message"]||"Unknown error";C=new R(E,z,g)}if(d){let E=d;d=null,E(C?{done:!0,value:void 0}:{done:!0,value:void 0})}},onError:g=>{if(clearTimeout(A),this.pendingStreamRequests.delete(l),C=g,v=!0,d){let m=d;d=null,m({done:!0,value:void 0})}},timeout:A});let $=U(p);try{this.dataChannel.send($)}catch(g){throw clearTimeout(A),this.pendingStreamRequests.delete(l),g}let _={next:()=>f.length>0?Promise.resolve({done:!1,value:f.shift()}):v?C?Promise.reject(C):Promise.resolve({done:!0,value:void 0}):new Promise(g=>{d=g})};return{headers:{},get trailers(){return O},messages:{[Symbol.asyncIterator]:()=>_}}}async call(e,n){if(this.closed)throw new Error("Transport is closed");let t=e.headers["x-request-id"];if(!t)throw new Error("Request envelope must include x-request-id header");let r=n?.timeout||3e4,o=new Promise((h,p)=>{let u=setTimeout(()=>{this.pendingRequests.delete(t),p(new Error(`Request timeout after ${r}ms`))},r);this.pendingRequests.set(t,{resolve:h,reject:p,timeout:u})}),c=U(e);try{this.dataChannel.send(c)}catch(h){let p=this.pendingRequests.get(t);throw p&&(clearTimeout(p.timeout),this.pendingRequests.delete(t)),h}let l=await o;if(x(l)){let h=W(l);throw h?new R(h.code,h.message,l.trailers):new R(T.UNKNOWN,"Unknown error",l.trailers)}return l}close(){if(this.closed)return;this.closed=!0;let e=new Error("Transport closed");for(let[n,t]of this.pendingRequests.entries())clearTimeout(t.timeout),t.reject(e);this.pendingRequests.clear();for(let[n,t]of this.pendingStreamRequests.entries())clearTimeout(t.timeout),t.onError(e);this.pendingStreamRequests.clear(),this.dataChannel.readyState==="open"&&this.dataChannel.close(),this.dataChannel.removeEventListener("message",this.handleMessage.bind(this)),this.dataChannel.removeEventListener("close",this.handleClose.bind(this)),this.dataChannel.removeEventListener("error",this.handleError.bind(this))}generateRequestId(){return this.requestIdCounter++,`req-${Date.now()}-${this.requestIdCounter}`}handleMessage(e){if(this.closed)return;let n=new Uint8Array(e.data);try{if(H(n)){this.handleStreamMessage(n);return}let t=F(n),r=t.headers["x-request-id"];if(!r){console.error("Received response without x-request-id header");return}let o=this.pendingRequests.get(r);if(!o){console.warn(`Received response for unknown request ID: ${r}`);return}clearTimeout(o.timeout),this.pendingRequests.delete(r),o.resolve(t)}catch(t){console.error("Failed to decode response:",t)}}handleStreamMessage(e){try{let n=B(e),t=this.pendingStreamRequests.get(n.requestId);if(!t){console.warn(`Received stream message for unknown request ID: ${n.requestId}`);return}if(n.flag===w.DATA){let{frames:r}=S(n.data);for(let o of r)o.flags===0&&t.onMessage(o.data)}else if(n.flag===w.END){let{frames:r}=S(n.data),o={};for(let c of r)c.flags===1&&(o=b(c.data));this.pendingStreamRequests.delete(n.requestId),t.onEnd(o)}}catch(n){console.error("Failed to handle stream message:",n)}}handleClose(){if(this.closed)return;let e=new Error("DataChannel closed");for(let[n,t]of this.pendingRequests.entries())clearTimeout(t.timeout),t.reject(e);this.pendingRequests.clear();for(let[n,t]of this.pendingStreamRequests.entries())clearTimeout(t.timeout),t.onError(e);this.pendingStreamRequests.clear(),this.closed=!0}handleError(e){console.error("DataChannel error:",e)}get channel(){return this.dataChannel}get isClosed(){return this.closed}get pendingCount(){return this.pendingRequests.size}};var V=[{urls:"stun:stun.l.google.com:19302"},{urls:"stun:stun1.l.google.com:19302"}],I=class{constructor(e,n=V){i(this,"signalingClient");i(this,"peerConnections",new Map);i(this,"iceServers");i(this,"onDataChannelOpen",null);i(this,"onDataChannelClose",null);i(this,"onDataChannelMessage",null);i(this,"onConnectionStateChange",null);i(this,"onError",null);this.signalingClient=e,this.iceServers=n,this.setupSignalingHandlers()}setupSignalingHandlers(){this.signalingClient.onAnswer=e=>{let{sdp:n,appId:t}=e;this.handleAnswer(t,n)},this.signalingClient.onIce=e=>{let{candidate:n,appId:t}=e;t&&this.handleIceCandidate(t,n)},this.signalingClient.onAppStatus=e=>{e.status==="offline"&&this.disconnect(e.appId)}}async connectToApp(e){if(this.peerConnections.has(e)){let o=this.peerConnections.get(e);if(o.dataChannel?.readyState==="open")return o.dataChannel;this.disconnect(e)}let n=new RTCPeerConnection({iceServers:this.iceServers}),t=n.createDataChannel("data",{ordered:!0}),r={pc:n,dataChannel:t,transport:null,appId:e};this.peerConnections.set(e,r),this.setupPeerConnectionHandlers(e,n),this.setupDataChannelHandlers(e,t);try{let o=await n.createOffer();return await n.setLocalDescription(o),this.signalingClient.sendOffer(e,o.sdp),new Promise((c,l)=>{let h=setTimeout(()=>{l(new Error("Data channel connection timeout")),this.disconnect(e)},3e4);t.onopen=()=>{clearTimeout(h),r.transport=new D(t),this.onDataChannelOpen?.({appId:e}),c(t)},t.onerror=p=>{clearTimeout(h),this.onError?.({appId:e,message:`Data channel error: ${p}`}),l(p)}})}catch(o){throw this.disconnect(e),this.onError?.({appId:e,message:`Failed to create offer: ${o}`}),o}}disconnect(e){if(e){let n=this.peerConnections.get(e);n&&(this.closePeerConnection(n),this.peerConnections.delete(e))}else{for(let[n,t]of this.peerConnections.entries())this.closePeerConnection(t);this.peerConnections.clear()}}sendMessage(e,n){let t=this.peerConnections.get(e);if(!t?.dataChannel){this.onError?.({appId:e,message:"No data channel available for this app"});return}if(t.dataChannel.readyState!=="open"){this.onError?.({appId:e,message:`Data channel is not open (state: ${t.dataChannel.readyState})`});return}try{t.dataChannel.send(n)}catch(r){this.onError?.({appId:e,message:`Failed to send message: ${r}`})}}getConnectionState(e){return this.peerConnections.get(e)?.pc.connectionState||null}getDataChannelState(e){return this.peerConnections.get(e)?.dataChannel?.readyState||null}getConnectedApps(){return Array.from(this.peerConnections.keys()).filter(e=>this.peerConnections.get(e)?.dataChannel?.readyState==="open")}getTransport(e){return this.peerConnections.get(e)?.transport||null}getDataChannel(e){return this.peerConnections.get(e)?.dataChannel||null}async handleAnswer(e,n){let t=this.peerConnections.get(e);if(!t){console.warn(`Received answer for unknown app: ${e}`);return}try{let r=new RTCSessionDescription({type:"answer",sdp:n});await t.pc.setRemoteDescription(r)}catch(r){this.onError?.({appId:e,message:`Failed to set remote description: ${r}`})}}async handleIceCandidate(e,n){let t=this.peerConnections.get(e);if(!t){console.warn(`Received ICE candidate for unknown app: ${e}`);return}try{await t.pc.addIceCandidate(n)}catch(r){this.onError?.({appId:e,message:`Failed to add ICE candidate: ${r}`})}}setupPeerConnectionHandlers(e,n){n.onicecandidate=t=>{t.candidate&&this.signalingClient.sendIce(t.candidate,e)},n.onconnectionstatechange=()=>{let t=n.connectionState;this.onConnectionStateChange?.({appId:e,state:t}),(t==="failed"||t==="closed")&&this.disconnect(e)},n.oniceconnectionstatechange=()=>{let t=n.iceConnectionState;(t==="failed"||t==="closed")&&this.onError?.({appId:e,message:`ICE connection ${t}`})},n.ondatachannel=t=>{console.warn("Unexpected data channel from remote peer:",t.channel.label)}}setupDataChannelHandlers(e,n){n.onopen=()=>{this.onDataChannelOpen?.({appId:e})},n.onclose=()=>{this.onDataChannelClose?.({appId:e})},n.onmessage=t=>{this.onDataChannelMessage?.({appId:e,data:t.data})},n.onerror=t=>{this.onError?.({appId:e,message:`Data channel error: ${t}`})}}closePeerConnection(e){let{pc:n,dataChannel:t,transport:r,appId:o}=e;if(r)try{r.close()}catch(c){console.error("Error closing transport:",c)}if(t)try{t.close()}catch(c){console.error("Error closing data channel:",c)}try{n.close()}catch(c){console.error("Error closing peer connection:",c)}this.onDataChannelClose?.({appId:o})}};var K="/grpc.reflection.v1alpha.ServerReflection/ListServices",L=class{constructor(e){i(this,"transport");this.transport=e}async listServices(e){return(await this.transport.unary(K,new Uint8Array(0),t=>t,t=>{let r=new TextDecoder().decode(t);return JSON.parse(r)},e)).message}static getMethodPath(e,n){return`/${e}/${n}`}};function a(s,...e){console.log(`[ReflectionUI:${s}]`,...e)}var k=class{constructor(){i(this,"signalingClient",null);i(this,"webrtcClient",null);i(this,"reflectionClient",null);i(this,"apps",new Map);i(this,"userInfo",null);i(this,"connectedAppId",null);i(this,"loginSection");i(this,"userSection");i(this,"appListSection");i(this,"reflectionSection");i(this,"userEmailSpan");i(this,"appSelectElement");i(this,"wsStatusSpan");i(this,"logoutBtn");i(this,"connectBtn");i(this,"resultsDiv");i(this,"statusDiv");a("constructor","Initializing ReflectionUIManager"),document.readyState==="loading"?document.addEventListener("DOMContentLoaded",()=>this.initialize()):this.initialize()}initialize(){a("initialize","DOM ready, initializing..."),this.initializeDOM(),this.checkAuthStatus()}initializeDOM(){this.loginSection=document.getElementById("login-section"),this.userSection=document.getElementById("user-section"),this.appListSection=document.getElementById("app-list-section"),this.reflectionSection=document.getElementById("reflection-section"),this.userEmailSpan=document.getElementById("user-email"),this.appSelectElement=document.getElementById("app-select"),this.wsStatusSpan=document.getElementById("ws-status"),this.logoutBtn=document.getElementById("logout-btn"),this.connectBtn=document.getElementById("connect-btn"),this.resultsDiv=document.getElementById("results"),this.statusDiv=document.getElementById("status"),this.logoutBtn.addEventListener("click",()=>this.handleLogout()),document.getElementById("login-btn")?.addEventListener("click",()=>this.handleLogin()),this.connectBtn.addEventListener("click",()=>this.handleConnectAndList())}async checkAuthStatus(){a("checkAuthStatus","Checking auth status...");try{let e=await fetch("/api/me");a("checkAuthStatus","Response status:",e.status),e.ok?(this.userInfo=await e.json(),a("checkAuthStatus","User info:",this.userInfo),this.showUserInterface(),this.initializeWebSocket()):(a("checkAuthStatus","Not authenticated, showing login"),this.showLogin())}catch(e){console.error("Auth check failed:",e),a("checkAuthStatus","Error:",e),this.showLogin()}}clearToken(){document.cookie="token=; expires=Thu, 01 Jan 1970 00:00:00 UTC; path=/;",localStorage.removeItem("token")}showLogin(){this.loginSection.style.display="block",this.userSection.style.display="none",this.appListSection.style.display="none",this.reflectionSection.style.display="none"}showUserInterface(){this.loginSection.style.display="none",this.userSection.style.display="block",this.appListSection.style.display="block",this.reflectionSection.style.display="block",this.userInfo&&(this.userEmailSpan.textContent=this.userInfo.email)}handleLogin(){window.location.href="/auth/login"}handleLogout(){this.clearToken(),this.signalingClient&&this.signalingClient.disconnect(),this.webrtcClient&&this.webrtcClient.disconnect(),this.showLogin()}async initializeWebSocket(){let n=`${window.location.protocol==="https:"?"wss:":"ws:"}//${window.location.host}/ws`;a("initializeWebSocket","WebSocket URL:",n),this.signalingClient=new y(n),this.signalingClient.onConnected=()=>{a("WS:onConnected","WebSocket connected"),this.updateWSStatus("connected")},this.signalingClient.onDisconnected=()=>{a("WS:onDisconnected","WebSocket disconnected"),this.updateWSStatus("disconnected")},this.signalingClient.onAuthenticated=t=>{a("WS:onAuthenticated","Authenticated:",t),this.updateWSStatus("authenticated"),a("WS:onAuthenticated","Requesting app list..."),this.signalingClient?.getApps()},this.signalingClient.onAuthError=t=>{a("WS:onAuthError","Auth error:",t),this.updateWSStatus("error"),alert("Authentication failed: "+t.error),this.handleLogout()},this.signalingClient.onAppsListReceived=t=>{a("WS:onAppsListReceived","Apps list received:",JSON.stringify(t,null,2)),a("WS:onAppsListReceived","Number of apps:",t.apps?.length??0),t.apps.forEach((r,o)=>{a("WS:onAppsListReceived",`App ${o}:`,r),this.apps.set(r.appId,{id:r.appId,name:r.name,capabilities:r.capabilities,status:r.status})}),a("WS:onAppsListReceived","Total apps in map:",this.apps.size),this.renderAppList()},this.signalingClient.onAppStatus=t=>{a("WS:onAppStatus","App status update:",t);let r=this.apps.get(t.appId);r?(r.status=t.status,t.name&&(r.name=t.name),t.capabilities&&(r.capabilities=t.capabilities)):this.apps.set(t.appId,{id:t.appId,name:t.name||t.appId,capabilities:t.capabilities,status:t.status}),a("WS:onAppStatus","Apps map after update:",Array.from(this.apps.entries())),this.renderAppList()},this.signalingClient.onError=t=>{a("WS:onError","WebSocket error:",t),this.setStatus("Error: "+t.message,"error")},a("initializeWebSocket","Initializing WebRTC client"),this.webrtcClient=new I(this.signalingClient),this.webrtcClient.onDataChannelOpen=({appId:t})=>{a("WebRTC:onDataChannelOpen","Data channel opened:",t),this.setStatus("Connected to "+t,"success")},this.webrtcClient.onDataChannelClose=({appId:t})=>{a("WebRTC:onDataChannelClose","Data channel closed:",t),this.setStatus("Disconnected from "+t,"info"),this.connectedAppId===t&&(this.connectedAppId=null,this.reflectionClient=null)},this.webrtcClient.onError=({appId:t,message:r})=>{a("WebRTC:onError","WebRTC error:",t,r),this.setStatus("Error: "+r,"error")};try{a("initializeWebSocket","Connecting to WebSocket..."),await this.signalingClient.connect(),a("initializeWebSocket","WebSocket connect() returned")}catch(t){a("initializeWebSocket","Failed to connect to WebSocket:",t),this.updateWSStatus("error")}}updateWSStatus(e){this.wsStatusSpan.textContent=e,this.wsStatusSpan.className=`status-${e}`}renderAppList(){a("renderAppList","Rendering app list..."),a("renderAppList","All apps:",Array.from(this.apps.values()));let e=Array.from(this.apps.values()).filter(n=>n.status==="online");a("renderAppList","Online apps:",e),this.appSelectElement.innerHTML='<option value="">-- Select an Online App --</option>'+e.map(n=>`<option value="${n.id}">${this.escapeHtml(n.name)} (${this.escapeHtml(n.id)})</option>`).join(""),this.connectBtn.disabled=e.length===0,a("renderAppList","Connect button disabled:",this.connectBtn.disabled)}async handleConnectAndList(){let e=this.appSelectElement.value;if(a("handleConnectAndList","Selected app ID:",e),!e){alert("Please select an app");return}if(!this.webrtcClient){a("handleConnectAndList","WebRTC client not initialized"),alert("WebRTC client not initialized");return}try{this.setStatus("Connecting to app...","info"),this.connectBtn.disabled=!0,a("handleConnectAndList","Calling webrtcClient.connectToApp..."),await this.webrtcClient.connectToApp(e),this.connectedAppId=e,a("handleConnectAndList","Connected to app via WebRTC"),this.setStatus("Connected! Listing services...","info"),a("handleConnectAndList","Getting transport...");let n=this.webrtcClient.getTransport(e);if(a("handleConnectAndList","Transport:",n),!n)throw new Error("Failed to get transport");a("handleConnectAndList","Creating ReflectionClient..."),this.reflectionClient=new L(n),a("handleConnectAndList","Calling listServices...");let t=await this.reflectionClient.listServices({timeout:1e4});a("handleConnectAndList","listServices response:",t),this.displayResults(t),this.setStatus("Services listed successfully","success")}catch(n){a("handleConnectAndList","Error:",n),console.error("Failed to connect or list services:",n),this.setStatus("Error: "+n,"error"),alert("Failed to list services: "+n)}finally{this.connectBtn.disabled=!1}}displayResults(e){if(!e.services||e.services.length===0){this.resultsDiv.innerHTML='<div class="no-results">No services found</div>';return}let n=e.services.map(t=>{let r=t.methods&&t.methods.length>0?`<ul class="methods-list">
            ${t.methods.map(o=>`<li class="method-item">${this.escapeHtml(o)}</li>`).join("")}
          </ul>`:'<div class="no-methods">No methods</div>';return`
        <div class="service-card">
          <div class="service-name">${this.escapeHtml(t.name)}</div>
          <div class="service-methods">
            <div class="methods-header">Methods:</div>
            ${r}
          </div>
        </div>
      `}).join("");this.resultsDiv.innerHTML=`
      <div class="results-header">Found ${e.services.length} service(s)</div>
      <div class="services-container">${n}</div>
      <div class="results-footer">
        <button class="btn btn-secondary" onclick="window.reflectionUI.showRawJSON()">
          Show Raw JSON
        </button>
      </div>
    `,window.reflectionResponse=e}showRawJSON(){let e=window.reflectionResponse;if(!e){alert("No response data available");return}let n=JSON.stringify(e,null,2);this.resultsDiv.innerHTML=`
      <div class="results-header">Raw JSON Response</div>
      <pre class="raw-json">${this.escapeHtml(n)}</pre>
      <div class="results-footer">
        <button class="btn btn-secondary" onclick="location.reload()">
          Refresh Page
        </button>
      </div>
    `}setStatus(e,n){this.statusDiv.textContent=e,this.statusDiv.className=`status-message status-${n}`,this.statusDiv.style.display="block"}escapeHtml(e){let n=document.createElement("div");return n.textContent=e,n.innerHTML}};function Z(){document.readyState==="loading"?document.addEventListener("DOMContentLoaded",()=>{window.reflectionUI=new k}):window.reflectionUI=new k}Z();})();
