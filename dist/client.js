var U=Object.defineProperty;var P=(r,e,t)=>e in r?U(r,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):r[e]=t;var i=(r,e,t)=>P(r,typeof e!="symbol"?e+"":e,t);var m=class{constructor(e,t=null){i(this,"ws",null);i(this,"wsUrl");i(this,"token");i(this,"reconnectAttempts",0);i(this,"maxReconnectAttempts",10);i(this,"reconnectTimeout",null);i(this,"isManualDisconnect",!1);i(this,"isAuthenticated",!1);i(this,"onAuthenticated",null);i(this,"onAuthError",null);i(this,"onAppStatus",null);i(this,"onAppsListReceived",null);i(this,"onOffer",null);i(this,"onAnswer",null);i(this,"onIce",null);i(this,"onConnected",null);i(this,"onDisconnected",null);i(this,"onError",null);this.wsUrl=e,this.token=t}async connect(){if(!(this.ws?.readyState===WebSocket.OPEN||this.ws?.readyState===WebSocket.CONNECTING))return this.isManualDisconnect=!1,new Promise((e,t)=>{try{let n=new URL(this.wsUrl);this.token&&n.searchParams.set("token",this.token),this.ws=new WebSocket(n.toString()),this.ws.onopen=()=>{this.reconnectAttempts=0,this.onConnected?.(),this.sendAuth(),e()},this.ws.onmessage=s=>{this.handleMessage(s.data)},this.ws.onerror=s=>{console.error("WebSocket error:",s),this.onError?.({message:"WebSocket error occurred"}),t(new Error("WebSocket connection error"))},this.ws.onclose=s=>{this.isAuthenticated=!1,this.onDisconnected?.(),this.isManualDisconnect||this.scheduleReconnect()}}catch(n){t(n)}})}disconnect(){this.isManualDisconnect=!0,this.isAuthenticated=!1,this.reconnectTimeout!==null&&(clearTimeout(this.reconnectTimeout),this.reconnectTimeout=null),this.ws&&(this.ws.close(),this.ws=null)}isConnected(){return this.ws?.readyState===WebSocket.OPEN&&this.isAuthenticated}sendAuth(){this.send({type:"auth",payload:{token:this.token}})}sendOffer(e,t){this.send({type:"offer",payload:{targetAppId:e,sdp:t}})}sendAnswer(e){this.send({type:"answer",payload:{sdp:e}})}sendIce(e,t){this.send({type:"ice",payload:{candidate:e,targetAppId:t}})}getApps(){this.send({type:"get_apps",payload:{}})}send(e){if(this.ws?.readyState!==WebSocket.OPEN){console.error("WebSocket is not open. Cannot send message:",e);return}try{this.ws.send(JSON.stringify(e))}catch(t){console.error("Failed to send message:",t),this.onError?.({message:"Failed to send message"})}}handleMessage(e){try{let t=JSON.parse(e);switch(t.type){case"auth_ok":this.isAuthenticated=!0,this.onAuthenticated?.(t.payload);break;case"auth_error":this.isAuthenticated=!1,this.onAuthError?.(t.payload);break;case"apps_list":this.onAppsListReceived?.(t.payload);break;case"app_status":this.onAppStatus?.(t.payload);break;case"offer":this.onOffer?.(t.payload);break;case"answer":this.onAnswer?.(t.payload);break;case"ice":this.onIce?.(t.payload);break;case"error":this.onError?.(t.payload);break;default:console.warn("Unknown message type:",t.type)}}catch(t){console.error("Failed to parse message:",t),this.onError?.({message:"Failed to parse server message"})}}scheduleReconnect(){if(this.reconnectAttempts>=this.maxReconnectAttempts){console.error("Max reconnection attempts reached"),this.onError?.({message:"Failed to reconnect after multiple attempts"});return}let e=Math.min(1e3*Math.pow(2,this.reconnectAttempts),3e4);this.reconnectAttempts++,console.log(`Reconnecting in ${e}ms (attempt ${this.reconnectAttempts}/${this.maxReconnectAttempts})`),this.reconnectTimeout=window.setTimeout(()=>{this.connect().catch(t=>{console.error("Reconnection failed:",t)})},e)}updateToken(e){this.token=e,this.ws?.readyState===WebSocket.OPEN&&(this.disconnect(),this.connect().catch(t=>{console.error("Failed to reconnect with new token:",t)}))}};function A(r){let e=r.data.length,t=new Uint8Array(5+e);return t[0]=r.flags,new DataView(t.buffer).setUint32(1,e,!1),t.set(r.data,5),t}function R(r){let e=[],t=0;for(;t<r.length;){if(t+5>r.length)return{frames:e,remaining:r.slice(t)};let n=r[t],o=new DataView(r.buffer,r.byteOffset+t+1,4).getUint32(0,!1),a=t+5+o;if(a>r.length)return{frames:e,remaining:r.slice(t)};let l=r.slice(t+5,a);e.push({flags:n,data:l}),t=a}return{frames:e,remaining:new Uint8Array(0)}}function T(r){return{flags:0,data:r}}function L(r){let t=new TextDecoder("utf-8").decode(r),n={},s=t.split(`\r
`);for(let o of s){if(!o.trim())continue;let a=o.indexOf(":");if(a===-1)continue;let l=o.substring(0,a).trim().toLowerCase(),c=o.substring(a+1).trim();n[l]=c}return n}var w={OK:0,CANCELLED:1,UNKNOWN:2,INVALID_ARGUMENT:3,DEADLINE_EXCEEDED:4,NOT_FOUND:5,ALREADY_EXISTS:6,PERMISSION_DENIED:7,RESOURCE_EXHAUSTED:8,FAILED_PRECONDITION:9,ABORTED:10,OUT_OF_RANGE:11,UNIMPLEMENTED:12,INTERNAL:13,UNAVAILABLE:14,DATA_LOSS:15,UNAUTHENTICATED:16};function k(r){let e=new TextEncoder,t=e.encode(r.path),n=t.length,s=JSON.stringify(r.headers),o=e.encode(s),a=o.length,l=T(r.message),c=A(l),h=4+n+4+a+c.length,d=new Uint8Array(h),g=new DataView(d.buffer),p=0;return g.setUint32(p,n,!1),p+=4,d.set(t,p),p+=n,g.setUint32(p,a,!1),p+=4,d.set(o,p),p+=a,d.set(c,p),d}function D(r){let e=new TextDecoder("utf-8"),t=new DataView(r.buffer,r.byteOffset),n=0;if(n+4>r.length)throw new Error("Incomplete response: missing headers length");let s=t.getUint32(n,!1);if(n+=4,n+s>r.length)throw new Error("Incomplete response: missing headers");let o=r.slice(n,n+s),a=e.decode(o),l=JSON.parse(a);n+=s;let c=r.slice(n),{frames:h,remaining:d}=R(c);if(d.length>0)throw new Error("Incomplete response: partial frame remaining");let g=[],p={};for(let u of h)if(u.flags===0)g.push(u.data);else if(u.flags===1)p=L(u.data);else throw new Error(`Unknown frame flags: ${u.flags}`);return{headers:l,messages:g,trailers:p}}function y(r){let e=r.trailers["grpc-status"];return e?parseInt(e,10)!==w.OK:!1}function I(r){if(!y(r))return null;let e=parseInt(r.trailers["grpc-status"]||"2",10),t=r.trailers["grpc-message"]||"Unknown error";return{code:e,message:t}}var C=class extends Error{constructor(t,n,s){super(n);this.code=t;this.trailers=s;this.name="GrpcError"}},v=class{constructor(e){i(this,"dataChannel");i(this,"pendingRequests",new Map);i(this,"requestIdCounter",0);i(this,"closed",!1);this.dataChannel=e,this.dataChannel.binaryType="arraybuffer",this.dataChannel.addEventListener("message",this.handleMessage.bind(this)),this.dataChannel.addEventListener("close",this.handleClose.bind(this)),this.dataChannel.addEventListener("error",this.handleError.bind(this))}async unary(e,t,n,s,o){let a=n(t),c={"x-request-id":this.generateRequestId(),...o?.headers||{}},h={path:e,headers:c,message:a},d=await this.call(h,o);if(d.messages.length===0)throw new Error("No response message received for unary call");if(d.messages.length>1)throw new Error(`Expected single response message, got ${d.messages.length}`);return{message:s(d.messages[0]),headers:d.headers,trailers:d.trailers}}async call(e,t){if(this.closed)throw new Error("Transport is closed");let n=e.headers["x-request-id"];if(!n)throw new Error("Request envelope must include x-request-id header");let s=t?.timeout||3e4,o=new Promise((c,h)=>{let d=setTimeout(()=>{this.pendingRequests.delete(n),h(new Error(`Request timeout after ${s}ms`))},s);this.pendingRequests.set(n,{resolve:c,reject:h,timeout:d})}),a=k(e);try{this.dataChannel.send(a)}catch(c){let h=this.pendingRequests.get(n);throw h&&(clearTimeout(h.timeout),this.pendingRequests.delete(n)),c}let l=await o;if(y(l)){let c=I(l);throw c?new C(c.code,c.message,l.trailers):new C(w.UNKNOWN,"Unknown error",l.trailers)}return l}close(){if(this.closed)return;this.closed=!0;let e=new Error("Transport closed");for(let[t,n]of this.pendingRequests.entries())clearTimeout(n.timeout),n.reject(e);this.pendingRequests.clear(),this.dataChannel.readyState==="open"&&this.dataChannel.close(),this.dataChannel.removeEventListener("message",this.handleMessage.bind(this)),this.dataChannel.removeEventListener("close",this.handleClose.bind(this)),this.dataChannel.removeEventListener("error",this.handleError.bind(this))}generateRequestId(){return this.requestIdCounter++,`req-${Date.now()}-${this.requestIdCounter}`}handleMessage(e){if(this.closed)return;let t=new Uint8Array(e.data);try{let n=D(t),s=n.headers["x-request-id"];if(!s){console.error("Received response without x-request-id header");return}let o=this.pendingRequests.get(s);if(!o){console.warn(`Received response for unknown request ID: ${s}`);return}clearTimeout(o.timeout),this.pendingRequests.delete(s),o.resolve(n)}catch(n){console.error("Failed to decode response:",n)}}handleClose(){if(this.closed)return;let e=new Error("DataChannel closed");for(let[t,n]of this.pendingRequests.entries())clearTimeout(n.timeout),n.reject(e);this.pendingRequests.clear(),this.closed=!0}handleError(e){console.error("DataChannel error:",e)}get channel(){return this.dataChannel}get isClosed(){return this.closed}get pendingCount(){return this.pendingRequests.size}};var $=[{urls:"stun:stun.l.google.com:19302"},{urls:"stun:stun1.l.google.com:19302"}],f=class{constructor(e,t=$){i(this,"signalingClient");i(this,"peerConnections",new Map);i(this,"iceServers");i(this,"onDataChannelOpen",null);i(this,"onDataChannelClose",null);i(this,"onDataChannelMessage",null);i(this,"onConnectionStateChange",null);i(this,"onError",null);this.signalingClient=e,this.iceServers=t,this.setupSignalingHandlers()}setupSignalingHandlers(){this.signalingClient.onAnswer=e=>{let{sdp:t,appId:n}=e;this.handleAnswer(n,t)},this.signalingClient.onIce=e=>{let{candidate:t,appId:n}=e;n&&this.handleIceCandidate(n,t)},this.signalingClient.onAppStatus=e=>{e.status==="offline"&&this.disconnect(e.appId)}}async connectToApp(e){if(this.peerConnections.has(e)){let o=this.peerConnections.get(e);if(o.dataChannel?.readyState==="open")return o.dataChannel;this.disconnect(e)}let t=new RTCPeerConnection({iceServers:this.iceServers}),n=t.createDataChannel("data",{ordered:!0}),s={pc:t,dataChannel:n,transport:null,appId:e};this.peerConnections.set(e,s),this.setupPeerConnectionHandlers(e,t),this.setupDataChannelHandlers(e,n);try{let o=await t.createOffer();return await t.setLocalDescription(o),this.signalingClient.sendOffer(e,o.sdp),new Promise((a,l)=>{let c=setTimeout(()=>{l(new Error("Data channel connection timeout")),this.disconnect(e)},3e4);n.onopen=()=>{clearTimeout(c),s.transport=new v(n),this.onDataChannelOpen?.({appId:e}),a(n)},n.onerror=h=>{clearTimeout(c),this.onError?.({appId:e,message:`Data channel error: ${h}`}),l(h)}})}catch(o){throw this.disconnect(e),this.onError?.({appId:e,message:`Failed to create offer: ${o}`}),o}}disconnect(e){if(e){let t=this.peerConnections.get(e);t&&(this.closePeerConnection(t),this.peerConnections.delete(e))}else{for(let[t,n]of this.peerConnections.entries())this.closePeerConnection(n);this.peerConnections.clear()}}sendMessage(e,t){let n=this.peerConnections.get(e);if(!n?.dataChannel){this.onError?.({appId:e,message:"No data channel available for this app"});return}if(n.dataChannel.readyState!=="open"){this.onError?.({appId:e,message:`Data channel is not open (state: ${n.dataChannel.readyState})`});return}try{n.dataChannel.send(t)}catch(s){this.onError?.({appId:e,message:`Failed to send message: ${s}`})}}getConnectionState(e){return this.peerConnections.get(e)?.pc.connectionState||null}getDataChannelState(e){return this.peerConnections.get(e)?.dataChannel?.readyState||null}getConnectedApps(){return Array.from(this.peerConnections.keys()).filter(e=>this.peerConnections.get(e)?.dataChannel?.readyState==="open")}getTransport(e){return this.peerConnections.get(e)?.transport||null}getDataChannel(e){return this.peerConnections.get(e)?.dataChannel||null}async handleAnswer(e,t){let n=this.peerConnections.get(e);if(!n){console.warn(`Received answer for unknown app: ${e}`);return}try{let s=new RTCSessionDescription({type:"answer",sdp:t});await n.pc.setRemoteDescription(s)}catch(s){this.onError?.({appId:e,message:`Failed to set remote description: ${s}`})}}async handleIceCandidate(e,t){let n=this.peerConnections.get(e);if(!n){console.warn(`Received ICE candidate for unknown app: ${e}`);return}try{await n.pc.addIceCandidate(t)}catch(s){this.onError?.({appId:e,message:`Failed to add ICE candidate: ${s}`})}}setupPeerConnectionHandlers(e,t){t.onicecandidate=n=>{n.candidate&&this.signalingClient.sendIce(n.candidate,e)},t.onconnectionstatechange=()=>{let n=t.connectionState;this.onConnectionStateChange?.({appId:e,state:n}),(n==="failed"||n==="closed")&&this.disconnect(e)},t.oniceconnectionstatechange=()=>{let n=t.iceConnectionState;(n==="failed"||n==="closed")&&this.onError?.({appId:e,message:`ICE connection ${n}`})},t.ondatachannel=n=>{console.warn("Unexpected data channel from remote peer:",n.channel.label)}}setupDataChannelHandlers(e,t){t.onopen=()=>{this.onDataChannelOpen?.({appId:e})},t.onclose=()=>{this.onDataChannelClose?.({appId:e})},t.onmessage=n=>{this.onDataChannelMessage?.({appId:e,data:n.data})},t.onerror=n=>{this.onError?.({appId:e,message:`Data channel error: ${n}`})}}closePeerConnection(e){let{pc:t,dataChannel:n,transport:s,appId:o}=e;if(s)try{s.close()}catch(a){console.error("Error closing transport:",a)}if(n)try{n.close()}catch(a){console.error("Error closing data channel:",a)}try{t.close()}catch(a){console.error("Error closing peer connection:",a)}this.onDataChannelClose?.({appId:o})}};var b="cf_wbrtc_auth_token",S=class{constructor(e){i(this,"authServerUrl");i(this,"storage");this.authServerUrl=e.authServerUrl.replace(/\/$/,""),this.storage=e.storage==="sessionStorage"?sessionStorage:localStorage}login(e){let t=e||window.location.href,n=`${this.authServerUrl}/auth/login?return=${encodeURIComponent(t)}`;window.location.href=n}handleCallback(){let e=new URL(window.location.href),t=e.searchParams.get("token");return t?(this.storage.setItem(b,t),e.searchParams.delete("token"),window.history.replaceState({},document.title,e.toString()),t):null}getToken(){return this.storage.getItem(b)}isLoggedIn(){return this.getToken()!==null}logout(){this.storage.removeItem(b)}getWebSocketUrl(){let e=this.getToken(),t=this.authServerUrl.startsWith("https")?"wss":"ws",n=this.authServerUrl.replace(/^https?:\/\//,""),s=`${t}://${n}/ws`;return e?`${s}?token=${encodeURIComponent(e)}`:s}async verifyToken(){let e=this.getToken();if(!e)return null;try{let t=await fetch(`${this.authServerUrl}/api/me`,{headers:{Authorization:`Bearer ${e}`}});return t.ok?await t.json():(this.logout(),null)}catch(t){return console.error("Failed to verify token:",t),null}}};var E=class{constructor(){i(this,"signalingClient",null);i(this,"webrtcClient",null);i(this,"apps",new Map);i(this,"userInfo",null);i(this,"messageLog",[]);i(this,"loginSection");i(this,"userSection");i(this,"appListSection");i(this,"connectionSection");i(this,"messageSection");i(this,"userEmailSpan");i(this,"appListDiv");i(this,"messageLogDiv");i(this,"wsStatusSpan");i(this,"logoutBtn");this.initializeDOM(),this.checkAuthStatus()}initializeDOM(){this.loginSection=document.getElementById("login-section"),this.userSection=document.getElementById("user-section"),this.appListSection=document.getElementById("app-list-section"),this.connectionSection=document.getElementById("connection-section"),this.messageSection=document.getElementById("message-section"),this.userEmailSpan=document.getElementById("user-email"),this.appListDiv=document.getElementById("app-list"),this.messageLogDiv=document.getElementById("message-log"),this.wsStatusSpan=document.getElementById("ws-status"),this.logoutBtn=document.getElementById("logout-btn"),this.logoutBtn.addEventListener("click",()=>this.handleLogout()),document.getElementById("login-btn")?.addEventListener("click",()=>this.handleLogin()),document.getElementById("refresh-apps-btn")?.addEventListener("click",()=>this.refreshApps()),document.getElementById("send-message-btn")?.addEventListener("click",()=>this.handleSendMessage()),document.getElementById("clear-log-btn")?.addEventListener("click",()=>this.clearMessageLog())}async checkAuthStatus(){try{let e=await fetch("/api/me");e.ok?(this.userInfo=await e.json(),this.showUserInterface(),this.initializeWebSocket()):this.showLogin()}catch(e){console.error("Auth check failed:",e),this.showLogin()}}getToken(){let e=document.cookie.split(";");for(let t of e){let[n,s]=t.trim().split("=");if(n==="token")return s}return localStorage.getItem("token")}clearToken(){document.cookie="token=; expires=Thu, 01 Jan 1970 00:00:00 UTC; path=/;",localStorage.removeItem("token")}showLogin(){this.loginSection.style.display="block",this.userSection.style.display="none",this.appListSection.style.display="none",this.connectionSection.style.display="none",this.messageSection.style.display="none"}showUserInterface(){this.loginSection.style.display="none",this.userSection.style.display="block",this.appListSection.style.display="block",this.connectionSection.style.display="block",this.messageSection.style.display="block",this.userInfo&&(this.userEmailSpan.textContent=this.userInfo.email)}handleLogin(){window.location.href="/auth/login"}handleLogout(){this.clearToken(),this.signalingClient&&this.signalingClient.disconnect(),this.webrtcClient&&this.webrtcClient.disconnect(),this.showLogin()}async initializeWebSocket(){let t=`${window.location.protocol==="https:"?"wss:":"ws:"}//${window.location.host}/ws`;this.signalingClient=new m(t),this.signalingClient.onConnected=()=>{this.updateWSStatus("connected")},this.signalingClient.onDisconnected=()=>{this.updateWSStatus("disconnected")},this.signalingClient.onAuthenticated=n=>{console.log("Authenticated:",n),this.updateWSStatus("authenticated"),this.signalingClient?.getApps()},this.signalingClient.onAuthError=n=>{console.error("Auth error:",n),this.updateWSStatus("error"),alert("Authentication failed: "+n.error),this.handleLogout()},this.signalingClient.onAppsListReceived=n=>{console.log("Apps list received:",n),n.apps.forEach(s=>{this.apps.set(s.appId,{id:s.appId,name:s.name,capabilities:s.capabilities,status:s.status})}),this.renderAppList()},this.signalingClient.onAppStatus=n=>{console.log("App status update:",n);let s=this.apps.get(n.appId);s?(s.status=n.status,n.name&&(s.name=n.name),n.capabilities&&(s.capabilities=n.capabilities)):this.apps.set(n.appId,{id:n.appId,name:n.name||n.appId,capabilities:n.capabilities,status:n.status}),this.renderAppList()},this.signalingClient.onError=n=>{console.error("WebSocket error:",n),this.addLog("System","Error: "+n.message,"received")},this.webrtcClient=new f(this.signalingClient),this.webrtcClient.onDataChannelOpen=({appId:n})=>{console.log("Data channel opened:",n),this.addLog(n,"Connection established","received"),this.renderAppList()},this.webrtcClient.onDataChannelClose=({appId:n})=>{console.log("Data channel closed:",n),this.addLog(n,"Connection closed","received"),this.renderAppList()},this.webrtcClient.onDataChannelMessage=({appId:n,data:s})=>{console.log("Message from app:",n,s);let o=typeof s=="string"?s:`[Binary data: ${s.byteLength} bytes]`;this.addLog(n,o,"received")},this.webrtcClient.onConnectionStateChange=({appId:n,state:s})=>{console.log("Connection state change:",n,s),this.renderAppList()},this.webrtcClient.onError=({appId:n,message:s})=>{console.error("WebRTC error:",n,s),this.addLog(n||"System","Error: "+s,"received")};try{await this.signalingClient.connect()}catch(n){console.error("Failed to connect to WebSocket:",n),this.updateWSStatus("error")}}updateWSStatus(e){this.wsStatusSpan.textContent=e,this.wsStatusSpan.className=`status-${e}`}async refreshApps(){if(this.signalingClient?.isConnected())this.signalingClient.getApps();else try{let e=this.getToken(),t=await fetch("/api/apps",{headers:{Authorization:`Bearer ${e}`}});if(t.ok){let n=await t.json();this.apps.clear(),n.apps.forEach(s=>{this.apps.set(s.id,{id:s.id,name:s.name,capabilities:s.capabilities,status:"offline"})}),this.renderAppList()}}catch(e){console.error("Failed to fetch apps:",e)}}renderAppList(){let e=Array.from(this.apps.values());if(e.length===0){this.appListDiv.innerHTML='<p class="no-apps">No apps registered. Register an app to get started.</p>';return}this.appListDiv.innerHTML=e.map(t=>{let n=t.status==="online",s=this.webrtcClient?.getConnectionState(t.id),o=this.webrtcClient?.getDataChannelState(t.id),a=o==="open";return`
        <div class="app-card ${n?"online":"offline"}">
          <div class="app-header">
            <span class="app-name">${this.escapeHtml(t.name)}</span>
            <span class="app-status ${n?"status-online":"status-offline"}">
              ${n?"\u25CF Online":"\u25CB Offline"}
            </span>
          </div>
          <div class="app-details">
            <div class="app-id">ID: ${this.escapeHtml(t.id)}</div>
            ${t.capabilities&&t.capabilities.length>0?`<div class="app-capabilities">Capabilities: ${t.capabilities.join(", ")}</div>`:""}
            ${s?`<div class="app-connection-state">WebRTC: ${s}</div>`:""}
            ${o?`<div class="app-datachannel-state">DataChannel: ${o}</div>`:""}
          </div>
          <div class="app-actions">
            ${n&&!a?`<button class="btn btn-primary" onclick="window.uiManager.connectToApp('${t.id}')">Connect</button>`:""}
            ${a?`<button class="btn btn-danger" onclick="window.uiManager.disconnectFromApp('${t.id}')">Disconnect</button>`:""}
          </div>
        </div>
      `}).join("")}async connectToApp(e){if(!this.webrtcClient){alert("WebRTC client not initialized");return}try{this.addLog(e,"Connecting...","sent"),await this.webrtcClient.connectToApp(e),this.addLog(e,"Connected successfully","received")}catch(t){console.error("Failed to connect to app:",t),this.addLog(e,"Connection failed: "+t,"received"),alert("Failed to connect to app: "+t)}}disconnectFromApp(e){this.webrtcClient&&(this.webrtcClient.disconnect(e),this.addLog(e,"Disconnected","sent"),this.renderAppList())}handleSendMessage(){let e=document.getElementById("message-input"),t=document.getElementById("target-app"),n=e.value.trim(),s=t.value;if(!n){alert("Please enter a message");return}if(!s){alert("Please select a target app");return}if(!this.webrtcClient){alert("WebRTC client not initialized");return}try{this.webrtcClient.sendMessage(s,n),this.addLog(s,n,"sent"),e.value=""}catch(o){console.error("Failed to send message:",o),alert("Failed to send message: "+o)}}addLog(e,t,n){let s={timestamp:new Date,appId:e,direction:n,data:t};this.messageLog.push(s),this.messageLog.length>100&&this.messageLog.shift(),this.renderMessageLog(),this.updateTargetAppDropdown()}renderMessageLog(){this.messageLogDiv.innerHTML=this.messageLog.slice().reverse().map(e=>{let t=e.timestamp.toLocaleTimeString(),n=e.direction==="sent"?"log-sent":"log-received",s=e.direction==="sent"?"\u2192":"\u2190";return`
          <div class="log-entry ${n}">
            <span class="log-time">${t}</span>
            <span class="log-direction">${s}</span>
            <span class="log-app">${this.escapeHtml(e.appId)}</span>
            <span class="log-data">${this.escapeHtml(e.data)}</span>
          </div>
        `}).join("")}updateTargetAppDropdown(){let e=document.getElementById("target-app"),t=e.value,n=this.webrtcClient?.getConnectedApps()||[];e.innerHTML='<option value="">-- Select App --</option>'+n.map(s=>{let o=this.apps.get(s),a=o?o.name:s;return`<option value="${s}">${this.escapeHtml(a)}</option>`}).join(""),n.includes(t)&&(e.value=t)}clearMessageLog(){this.messageLog=[],this.renderMessageLog()}escapeHtml(e){let t=document.createElement("div");return t.textContent=e,t.innerHTML}};function M(){document.readyState==="loading"?document.addEventListener("DOMContentLoaded",()=>{window.uiManager=new E}):window.uiManager=new E}M();export{S as AuthClient,m as SignalingClient,f as WebRTCClient,M as initializeUI};
