var V=Object.defineProperty;var J=(r,e,t)=>e in r?V(r,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):r[e]=t;var a=(r,e,t)=>J(r,typeof e!="symbol"?e+"":e,t);var D=class{constructor(e,t=null){a(this,"ws",null);a(this,"wsUrl");a(this,"token");a(this,"reconnectAttempts",0);a(this,"maxReconnectAttempts",10);a(this,"reconnectTimeout",null);a(this,"isManualDisconnect",!1);a(this,"isAuthenticated",!1);a(this,"onAuthenticated",null);a(this,"onAuthError",null);a(this,"onAppStatus",null);a(this,"onAppsListReceived",null);a(this,"onOffer",null);a(this,"onAnswer",null);a(this,"onIce",null);a(this,"onConnected",null);a(this,"onDisconnected",null);a(this,"onError",null);this.wsUrl=e,this.token=t}async connect(){if(!(this.ws?.readyState===WebSocket.OPEN||this.ws?.readyState===WebSocket.CONNECTING))return this.isManualDisconnect=!1,new Promise((e,t)=>{try{let n=new URL(this.wsUrl);this.token&&n.searchParams.set("token",this.token),this.ws=new WebSocket(n.toString()),this.ws.onopen=()=>{this.reconnectAttempts=0,this.onConnected?.(),this.sendAuth(),e()},this.ws.onmessage=s=>{this.handleMessage(s.data)},this.ws.onerror=s=>{console.error("WebSocket error:",s),this.onError?.({message:"WebSocket error occurred"}),t(new Error("WebSocket connection error"))},this.ws.onclose=s=>{this.isAuthenticated=!1,this.onDisconnected?.(),this.isManualDisconnect||this.scheduleReconnect()}}catch(n){t(n)}})}disconnect(){this.isManualDisconnect=!0,this.isAuthenticated=!1,this.reconnectTimeout!==null&&(clearTimeout(this.reconnectTimeout),this.reconnectTimeout=null),this.ws&&(this.ws.close(),this.ws=null)}isConnected(){return this.ws?.readyState===WebSocket.OPEN&&this.isAuthenticated}sendAuth(){this.send({type:"auth",payload:{token:this.token}})}sendOffer(e,t){this.send({type:"offer",payload:{targetAppId:e,sdp:t}})}sendAnswer(e){this.send({type:"answer",payload:{sdp:e}})}sendIce(e,t){this.send({type:"ice",payload:{candidate:e,targetAppId:t}})}getApps(){this.send({type:"get_apps",payload:{}})}send(e){if(this.ws?.readyState!==WebSocket.OPEN){console.error("WebSocket is not open. Cannot send message:",e);return}try{this.ws.send(JSON.stringify(e))}catch(t){console.error("Failed to send message:",t),this.onError?.({message:"Failed to send message"})}}handleMessage(e){try{let t=JSON.parse(e);switch(t.type){case"auth_ok":this.isAuthenticated=!0,this.onAuthenticated?.(t.payload);break;case"auth_error":this.isAuthenticated=!1,this.onAuthError?.(t.payload);break;case"apps_list":this.onAppsListReceived?.(t.payload);break;case"app_status":this.onAppStatus?.(t.payload);break;case"offer":this.onOffer?.(t.payload);break;case"answer":this.onAnswer?.(t.payload);break;case"ice":this.onIce?.(t.payload);break;case"error":this.onError?.(t.payload);break;default:console.warn("Unknown message type:",t.type)}}catch(t){console.error("Failed to parse message:",t),this.onError?.({message:"Failed to parse server message"})}}scheduleReconnect(){if(this.reconnectAttempts>=this.maxReconnectAttempts){console.error("Max reconnection attempts reached"),this.onError?.({message:"Failed to reconnect after multiple attempts"});return}let e=Math.min(1e3*Math.pow(2,this.reconnectAttempts),3e4);this.reconnectAttempts++,console.log(`Reconnecting in ${e}ms (attempt ${this.reconnectAttempts}/${this.maxReconnectAttempts})`),this.reconnectTimeout=window.setTimeout(()=>{this.connect().catch(t=>{console.error("Reconnection failed:",t)})},e)}updateToken(e){this.token=e,this.ws?.readyState===WebSocket.OPEN&&(this.disconnect(),this.connect().catch(t=>{console.error("Failed to reconnect with new token:",t)}))}};function F(r){let e=r.data.length,t=new Uint8Array(5+e);return t[0]=r.flags,new DataView(t.buffer).setUint32(1,e,!1),t.set(r.data,5),t}function R(r){let e=[],t=0;for(;t<r.length;){if(t+5>r.length)return{frames:e,remaining:r.slice(t)};let n=r[t],o=new DataView(r.buffer,r.byteOffset+t+1,4).getUint32(0,!1),i=t+5+o;if(i>r.length)return{frames:e,remaining:r.slice(t)};let c=r.slice(t+5,i);e.push({flags:n,data:c}),t=i}return{frames:e,remaining:new Uint8Array(0)}}function M(r){return{flags:0,data:r}}function S(r){let t=new TextDecoder("utf-8").decode(r),n={},s=t.split(`\r
`);for(let o of s){if(!o.trim())continue;let i=o.indexOf(":");if(i===-1)continue;let c=o.substring(0,i).trim().toLowerCase(),d=o.substring(i+1).trim();n[c]=d}return n}var b={OK:0,CANCELLED:1,UNKNOWN:2,INVALID_ARGUMENT:3,DEADLINE_EXCEEDED:4,NOT_FOUND:5,ALREADY_EXISTS:6,PERMISSION_DENIED:7,RESOURCE_EXHAUSTED:8,FAILED_PRECONDITION:9,ABORTED:10,OUT_OF_RANGE:11,UNIMPLEMENTED:12,INTERNAL:13,UNAVAILABLE:14,DATA_LOSS:15,UNAUTHENTICATED:16};function q(r){let e=new TextEncoder,t=e.encode(r.path),n=t.length,s=JSON.stringify(r.headers),o=e.encode(s),i=o.length,c=M(r.message),d=F(c),h=4+n+4+i+d.length,u=new Uint8Array(h),f=new DataView(u.buffer),l=0;return f.setUint32(l,n,!1),l+=4,u.set(t,l),l+=n,f.setUint32(l,i,!1),l+=4,u.set(o,l),l+=i,u.set(d,l),u}function N(r){let e=new TextDecoder("utf-8"),t=new DataView(r.buffer,r.byteOffset),n=0;if(n+4>r.length)throw new Error("Incomplete response: missing headers length");let s=t.getUint32(n,!1);if(n+=4,n+s>r.length)throw new Error("Incomplete response: missing headers");let o=r.slice(n,n+s),i=e.decode(o),c=JSON.parse(i);n+=s;let d=r.slice(n),{frames:h,remaining:u}=R(d);if(u.length>0)throw new Error("Incomplete response: partial frame remaining");let f=[],l={};for(let m of h)if(m.flags===0)f.push(m.data);else if(m.flags===1)l=S(m.data);else throw new Error(`Unknown frame flags: ${m.flags}`);return{headers:c,messages:f,trailers:l}}function U(r){let e=r.trailers["grpc-status"];return e?parseInt(e,10)!==b.OK:!1}function L(r){if(!U(r))return null;let e=parseInt(r.trailers["grpc-status"]||"2",10),t=r.trailers["grpc-message"]||"Unknown error";return{code:e,message:t}}var v={DATA:0,END:1};function _(r){let e=new DataView(r.buffer,r.byteOffset),t=new TextDecoder("utf-8"),n=0;if(n+4>r.length)throw new Error("Stream message too short");let s=e.getUint32(n,!1);if(n+=4,n+s+1>r.length)throw new Error("Incomplete stream message");let o=t.decode(r.slice(n,n+s));n+=s;let i=r[n];n++;let c=r.slice(n);return{requestId:o,flag:i,data:c}}function $(r){if(r.length<5)return!1;let t=new DataView(r.buffer,r.byteOffset).getUint32(0,!1);if(t===0||t>r.length-4||r[4]===123)return!1;if(t>=4&&4+t+1<=r.length&&String.fromCharCode(r[4],r[5],r[6],r[7])==="req-"){let o=r[4+t];return o===v.DATA||o===v.END}return!1}var w=class extends Error{constructor(t,n,s){super(n);this.code=t;this.trailers=s;this.name="GrpcError"}},T=class{constructor(e){a(this,"dataChannel");a(this,"pendingRequests",new Map);a(this,"pendingStreamRequests",new Map);a(this,"requestIdCounter",0);a(this,"closed",!1);this.dataChannel=e,this.dataChannel.binaryType="arraybuffer",this.dataChannel.addEventListener("message",this.handleMessage.bind(this)),this.dataChannel.addEventListener("close",this.handleClose.bind(this)),this.dataChannel.addEventListener("error",this.handleError.bind(this))}async unary(e,t,n,s,o){let i=n(t),d={"x-request-id":this.generateRequestId(),...o?.headers||{}},h={path:e,headers:d,message:i},u=await this.call(h,o);if(u.messages.length===0)throw new Error("No response message received for unary call");if(u.messages.length>1)throw new Error(`Expected single response message, got ${u.messages.length}`);return{message:s(u.messages[0]),headers:u.headers,trailers:u.trailers}}serverStreaming(e,t,n,s,o){if(this.closed)throw new Error("Transport is closed");let i=n(t),c=this.generateRequestId(),d={"x-request-id":c,...o?.headers||{}},h={path:e,headers:d,message:i},u=o?.timeout||3e4,f=[],l=null,m=!1,C=null,O={},A=setTimeout(()=>{this.pendingStreamRequests.delete(c),C=new Error(`Request timeout after ${u}ms`),m=!0,l&&l({done:!0,value:void 0})},u);this.pendingStreamRequests.set(c,{onMessage:g=>{try{let p=s(g);if(l){let E=l;l=null,E({done:!1,value:p})}else f.push(p)}catch(p){C=p instanceof Error?p:new Error(String(p))}},onEnd:g=>{clearTimeout(A),O=g,m=!0;let p=g["grpc-status"];if(p&&parseInt(p,10)!==b.OK){let E=parseInt(p,10),H=g["grpc-message"]||"Unknown error";C=new w(E,H,g)}if(l){let E=l;l=null,E(C?{done:!0,value:void 0}:{done:!0,value:void 0})}},onError:g=>{if(clearTimeout(A),this.pendingStreamRequests.delete(c),C=g,m=!0,l){let p=l;l=null,p({done:!0,value:void 0})}},timeout:A});let B=q(h);try{this.dataChannel.send(B)}catch(g){throw clearTimeout(A),this.pendingStreamRequests.delete(c),g}let W={next:()=>f.length>0?Promise.resolve({done:!1,value:f.shift()}):m?C?Promise.reject(C):Promise.resolve({done:!0,value:void 0}):new Promise(g=>{l=g})};return{headers:{},get trailers(){return O},messages:{[Symbol.asyncIterator]:()=>W}}}async call(e,t){if(this.closed)throw new Error("Transport is closed");let n=e.headers["x-request-id"];if(!n)throw new Error("Request envelope must include x-request-id header");let s=t?.timeout||3e4,o=new Promise((d,h)=>{let u=setTimeout(()=>{this.pendingRequests.delete(n),h(new Error(`Request timeout after ${s}ms`))},s);this.pendingRequests.set(n,{resolve:d,reject:h,timeout:u})}),i=q(e);try{this.dataChannel.send(i)}catch(d){let h=this.pendingRequests.get(n);throw h&&(clearTimeout(h.timeout),this.pendingRequests.delete(n)),d}let c=await o;if(U(c)){let d=L(c);throw d?new w(d.code,d.message,c.trailers):new w(b.UNKNOWN,"Unknown error",c.trailers)}return c}close(){if(this.closed)return;this.closed=!0;let e=new Error("Transport closed");for(let[t,n]of this.pendingRequests.entries())clearTimeout(n.timeout),n.reject(e);this.pendingRequests.clear();for(let[t,n]of this.pendingStreamRequests.entries())clearTimeout(n.timeout),n.onError(e);this.pendingStreamRequests.clear(),this.dataChannel.readyState==="open"&&this.dataChannel.close(),this.dataChannel.removeEventListener("message",this.handleMessage.bind(this)),this.dataChannel.removeEventListener("close",this.handleClose.bind(this)),this.dataChannel.removeEventListener("error",this.handleError.bind(this))}generateRequestId(){return this.requestIdCounter++,`req-${Date.now()}-${this.requestIdCounter}`}handleMessage(e){if(this.closed)return;let t=new Uint8Array(e.data);try{if($(t)){this.handleStreamMessage(t);return}let n=N(t),s=n.headers["x-request-id"];if(!s){console.error("Received response without x-request-id header");return}let o=this.pendingRequests.get(s);if(!o){console.warn(`Received response for unknown request ID: ${s}`);return}clearTimeout(o.timeout),this.pendingRequests.delete(s),o.resolve(n)}catch(n){console.error("Failed to decode response:",n)}}handleStreamMessage(e){try{let t=_(e),n=this.pendingStreamRequests.get(t.requestId);if(!n){console.warn(`Received stream message for unknown request ID: ${t.requestId}`);return}if(t.flag===v.DATA){let{frames:s}=R(t.data);for(let o of s)o.flags===0&&n.onMessage(o.data)}else if(t.flag===v.END){let{frames:s}=R(t.data),o={};for(let i of s)i.flags===1&&(o=S(i.data));this.pendingStreamRequests.delete(t.requestId),n.onEnd(o)}}catch(t){console.error("Failed to handle stream message:",t)}}handleClose(){if(this.closed)return;let e=new Error("DataChannel closed");for(let[t,n]of this.pendingRequests.entries())clearTimeout(n.timeout),n.reject(e);this.pendingRequests.clear();for(let[t,n]of this.pendingStreamRequests.entries())clearTimeout(n.timeout),n.onError(e);this.pendingStreamRequests.clear(),this.closed=!0}handleError(e){console.error("DataChannel error:",e)}get channel(){return this.dataChannel}get isClosed(){return this.closed}get pendingCount(){return this.pendingRequests.size}};var K=[{urls:"stun:stun.l.google.com:19302"},{urls:"stun:stun1.l.google.com:19302"}],P=class{constructor(e,t=K){a(this,"signalingClient");a(this,"peerConnections",new Map);a(this,"iceServers");a(this,"onDataChannelOpen",null);a(this,"onDataChannelClose",null);a(this,"onDataChannelMessage",null);a(this,"onConnectionStateChange",null);a(this,"onError",null);this.signalingClient=e,this.iceServers=t,this.setupSignalingHandlers()}setupSignalingHandlers(){this.signalingClient.onAnswer=e=>{let{sdp:t,appId:n}=e;this.handleAnswer(n,t)},this.signalingClient.onIce=e=>{let{candidate:t,appId:n}=e;n&&this.handleIceCandidate(n,t)},this.signalingClient.onAppStatus=e=>{e.status==="offline"&&this.disconnect(e.appId)}}async connectToApp(e){if(this.peerConnections.has(e)){let o=this.peerConnections.get(e);if(o.dataChannel?.readyState==="open")return o.dataChannel;this.disconnect(e)}let t=new RTCPeerConnection({iceServers:this.iceServers}),n=t.createDataChannel("data",{ordered:!0}),s={pc:t,dataChannel:n,transport:null,appId:e};this.peerConnections.set(e,s),this.setupPeerConnectionHandlers(e,t),this.setupDataChannelHandlers(e,n);try{let o=await t.createOffer();return await t.setLocalDescription(o),this.signalingClient.sendOffer(e,o.sdp),new Promise((i,c)=>{let d=setTimeout(()=>{c(new Error("Data channel connection timeout")),this.disconnect(e)},3e4);n.onopen=()=>{clearTimeout(d),s.transport=new T(n),this.onDataChannelOpen?.({appId:e}),i(n)},n.onerror=h=>{clearTimeout(d),this.onError?.({appId:e,message:`Data channel error: ${h}`}),c(h)}})}catch(o){throw this.disconnect(e),this.onError?.({appId:e,message:`Failed to create offer: ${o}`}),o}}disconnect(e){if(e){let t=this.peerConnections.get(e);t&&(this.closePeerConnection(t),this.peerConnections.delete(e))}else{for(let[t,n]of this.peerConnections.entries())this.closePeerConnection(n);this.peerConnections.clear()}}sendMessage(e,t){let n=this.peerConnections.get(e);if(!n?.dataChannel){this.onError?.({appId:e,message:"No data channel available for this app"});return}if(n.dataChannel.readyState!=="open"){this.onError?.({appId:e,message:`Data channel is not open (state: ${n.dataChannel.readyState})`});return}try{n.dataChannel.send(t)}catch(s){this.onError?.({appId:e,message:`Failed to send message: ${s}`})}}getConnectionState(e){return this.peerConnections.get(e)?.pc.connectionState||null}getDataChannelState(e){return this.peerConnections.get(e)?.dataChannel?.readyState||null}getConnectedApps(){return Array.from(this.peerConnections.keys()).filter(e=>this.peerConnections.get(e)?.dataChannel?.readyState==="open")}getTransport(e){return this.peerConnections.get(e)?.transport||null}getDataChannel(e){return this.peerConnections.get(e)?.dataChannel||null}async createDataChannel(e,t="stream",n){let s=this.peerConnections.get(e);if(!s)throw new Error(`No peer connection for app: ${e}`);if(s.pc.connectionState!=="connected")throw new Error(`Peer connection is not connected (state: ${s.pc.connectionState})`);let o=s.pc.createDataChannel(t,{ordered:!0,...n});return new Promise((i,c)=>{let d=setTimeout(()=>{c(new Error("DataChannel connection timeout"))},1e4);o.onopen=()=>{clearTimeout(d),i(o)},o.onerror=h=>{clearTimeout(d),c(h)}})}async handleAnswer(e,t){let n=this.peerConnections.get(e);if(!n){console.warn(`Received answer for unknown app: ${e}`);return}try{let s=new RTCSessionDescription({type:"answer",sdp:t});await n.pc.setRemoteDescription(s)}catch(s){this.onError?.({appId:e,message:`Failed to set remote description: ${s}`})}}async handleIceCandidate(e,t){let n=this.peerConnections.get(e);if(!n){console.warn(`Received ICE candidate for unknown app: ${e}`);return}try{await n.pc.addIceCandidate(t)}catch(s){this.onError?.({appId:e,message:`Failed to add ICE candidate: ${s}`})}}setupPeerConnectionHandlers(e,t){t.onicecandidate=n=>{n.candidate&&this.signalingClient.sendIce(n.candidate,e)},t.onconnectionstatechange=()=>{let n=t.connectionState;this.onConnectionStateChange?.({appId:e,state:n}),(n==="failed"||n==="closed")&&this.disconnect(e)},t.oniceconnectionstatechange=()=>{let n=t.iceConnectionState;(n==="failed"||n==="closed")&&this.onError?.({appId:e,message:`ICE connection ${n}`})},t.ondatachannel=n=>{console.warn("Unexpected data channel from remote peer:",n.channel.label)}}setupDataChannelHandlers(e,t){t.onopen=()=>{this.onDataChannelOpen?.({appId:e})},t.onclose=()=>{this.onDataChannelClose?.({appId:e})},t.onmessage=n=>{this.onDataChannelMessage?.({appId:e,data:n.data})},t.onerror=n=>{this.onError?.({appId:e,message:`Data channel error: ${n}`})}}closePeerConnection(e){let{pc:t,dataChannel:n,transport:s,appId:o}=e;if(s)try{s.close()}catch(i){console.error("Error closing transport:",i)}if(n)try{n.close()}catch(i){console.error("Error closing data channel:",i)}try{t.close()}catch(i){console.error("Error closing peer connection:",i)}this.onDataChannelClose?.({appId:o})}};var y="cf_wbrtc_auth_token",x=class{constructor(e){a(this,"authServerUrl");a(this,"storage");this.authServerUrl=e.authServerUrl.replace(/\/$/,""),this.storage=e.storage==="sessionStorage"?sessionStorage:localStorage}login(e){let t=e||window.location.href,n=`${this.authServerUrl}/auth/login?return=${encodeURIComponent(t)}`;window.location.href=n}async handleCallback(){let e=new URL(window.location.href),t=e.searchParams.get("code");if(!t)return null;e.searchParams.delete("code"),window.history.replaceState({},document.title,e.toString());try{let n=await fetch(`${this.authServerUrl}/auth/token`,{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify({code:t})});if(!n.ok)return console.error("Failed to exchange code for token"),null;let s=await n.json(),{token:o}=s;return console.log("[AuthClient] Saving token to storage, key:",y),console.log("[AuthClient] Storage type:",this.storage===localStorage?"localStorage":"sessionStorage"),this.storage.setItem(y,o),console.log("[AuthClient] Token saved, verify:",this.storage.getItem(y)?"SUCCESS":"FAILED"),o}catch(n){return console.error("Failed to exchange code for token:",n),null}}getToken(){return this.storage.getItem(y)}isLoggedIn(){return this.getToken()!==null}logout(){this.storage.removeItem(y)}getWebSocketUrl(){let e=this.getToken(),t=this.authServerUrl.startsWith("https")?"wss":"ws",n=this.authServerUrl.replace(/^https?:\/\//,""),s=`${t}://${n}/ws`;return e?`${s}?token=${encodeURIComponent(e)}`:s}async verifyToken(){let e=this.getToken();if(!e)return null;try{let t=await fetch(`${this.authServerUrl}/api/me`,{headers:{Authorization:`Bearer ${e}`}});return t.ok?await t.json():(this.logout(),null)}catch(t){return console.error("Failed to verify token:",t),null}}};export{x as AuthClient,D as SignalingClient,P as WebRTCClient};
